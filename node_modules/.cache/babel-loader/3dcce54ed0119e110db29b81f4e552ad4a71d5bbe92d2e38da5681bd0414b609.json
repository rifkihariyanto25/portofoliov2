{"ast":null,"code":"import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferGeometry, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { suspend } from 'suspend-react';\nimport { mergeVertices } from 'three-stdlib';\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef(undefined);\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\", \"ref\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n    mesh.geometry.dispose();\n    mesh.geometry = geometry;\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef(undefined);\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(props.ref);\n  const objectRef = useRef(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key =>\n  // Array.isArray(props[key]) ? [...props[key]] : props[key]\n  Array.isArray(props[key]) ? props[key] : [props[key]]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof props.ref == \"function\") {\n      props.ref(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n});\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\nconst _excluded$1 = [\"ref\", \"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo(props => {\n  const {\n      ref,\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(ref);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof ref === \"function\") {\n      ref(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\nconst _excluded = [\"ref\"],\n  _excluded2 = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo(_ref => {\n  let {\n      ref\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const rigidBodiesRef = useForwardedRef(ref, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded2);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => {\n      rigidBodiesRef.current[index] = body;\n    },\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n});\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef(undefined);\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };","map":{"version":3,"names":["Vector3","Vector3$1","Quaternion","Quaternion$1","ActiveEvents","ColliderDesc","EventQueue","RigidBodyDesc","CoefficientCombineRule","Collider","RapierCollider","RigidBody","RapierRigidBody","useFrame","useThree","React","useRef","useEffect","memo","useMemo","useContext","useState","createContext","useCallback","Fragment","Euler","Object3D","Matrix4","BufferGeometry","BufferAttribute","MathUtils","DynamicDrawUsage","suspend","mergeVertices","_toPrimitive","t","r","e","Symbol","toPrimitive","i","call","TypeError","String","Number","_toPropertyKey","_defineProperty","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","_quaternion","_vector3","_matrix4","_position","_rotation","_scale","vectorArrayToVector3","arr","x","y","z","rapierQuaternionToQuaternion","w","set","vector3ToRapierVector","v","Array","isArray","threeVector3","quaternionToRapierQuaternion","rigidBodyTypeMap","fixed","dynamic","kinematicPosition","kinematicVelocity","rigidBodyTypeFromString","type","scaleVertices","vertices","scale","scaledVerts","from","vectorToTuple","useConst","initialValue","ref","undefined","current","useRaf","callback","cb","raf","lastFrame","loop","now","performance","delta","requestAnimationFrame","cancelAnimationFrame","UseFrameStepper","onStep","updatePriority","_","dt","RafStepper","FrameStepper","createElement","FrameStepper$1","_objectWithoutPropertiesLoose","n","hasOwnProperty","indexOf","_objectWithoutProperties","propertyIsEnumerable","_excluded$2","scaleColliderArgs","shape","args","newArgs","slice","s","scaleArray","map","arg","index","createColliderFromOptions","options","world","getRigidBody","scaledArgs","desc","createCollider","immutableColliderOptions","massPropertiesConflictError","setColliderMassOptions","collider","density","mass","massProperties","Error","setDensity","setMass","setMassProperties","centerOfMass","principalAngularInertia","angularInertiaLocalFrame","mutableColliderOptions","sensor","setSensor","collisionGroups","setCollisionGroups","solverGroups","setSolverGroups","friction","setFriction","frictionCombineRule","setFrictionCombineRule","restitution","setRestitution","restitutionCombineRule","setRestitutionCombineRule","activeCollisionTypes","setActiveCollisionTypes","contactSkin","setContactSkin","quaternion","position","rotation","mutableColliderOptionKeys","setColliderOptions","states","state","get","handle","_state$worldParent","parentWorldScale","object","parent","getWorldScale","parentInvertedWorldMatrix","worldParent","matrixWorld","clone","invert","updateWorldMatrix","copy","premultiply","decompose","setTranslationWrtParent","setRotationWrtParent","setTranslation","setRotation","key","option","useUpdateColliderOptions","getCollider","props","mutablePropsAsFlatArray","flatMap","isChildOfMeshCollider","child","flag","traverseAncestors","a","userData","r3RapierType","createColliderState","rigidBodyObject","autoColliderMap","cuboid","ball","hull","trimesh","createColliderPropsFromChildren","ignoreMeshColliders","_ignoreMeshColliders","childColliderProps","invertedParentMatrixWorld","colliderFromChild","worldScale","colliders","rotationEuler","setFromQuaternion","geometry","offset","getColliderArgsFromGeometry","colliderProps","cleanRigidBodyPropsForCollider","includeInvisible","traverse","traverseVisible","computeBoundingBox","boundingBox","size","getSize","getCenter","computeBoundingSphere","boundingSphere","radius","center","_clonedGeometry$index","clonedGeometry","attributes","array","g","getActiveCollisionEventsFromProps","collision","onCollisionEnter","onCollisionExit","onIntersectionEnter","onIntersectionExit","contactForce","onContactForce","useColliderEvents","events","activeEvents","collisionEventsActive","contactForceEventsActive","hasCollisionEvent","hasContactForceEvent","setActiveEvents","COLLISION_EVENTS","CONTACT_FORCE_EVENTS","delete","rest","useMutableCallback","fn","useRapier","rapier","rapierContext","useBeforePhysicsStep","beforeStepCallbacks","add","useAfterPhysicsStep","afterStepCallbacks","useChildColliderProps","setColliderProps","Debug","mesh","buffers","debugRender","setAttribute","colors","dispose","frustumCulled","color","vertexColors","createSingletonProxy","createInstance","instance","handler","target","prop","Reflect","proxy","Proxy","reset","newInstance","getCollisionPayloadFromSource","other","_target$collider$stat","_target$rigidBody$sta","_other$collider$state","_other$rigidBody$stat","_other$collider$state2","_other$rigidBody$stat2","rigidBody","colliderObject","importRapier","init","Physics","children","timeStep","paused","interpolate","updateLoop","debug","gravity","allowedLinearError","predictionDistance","numSolverIterations","numAdditionalFrictionIterations","numInternalPgsIterations","minIslandSize","maxCcdSubsteps","contactNaturalFrequency","lengthUnit","invalidate","rigidBodyStates","Map","colliderStates","rigidBodyEvents","colliderEvents","eventQueue","Set","worldProxy","resetWorldProxy","setWorldProxy","World","free","integrationParameters","normalizedAllowedLinearError","normalizedPredictionDistance","contact_natural_frequency","getSourceFromColliderHandle","_collider$parent","colEvents","colliderState","rigidBodyHandle","rbEvents","rigidBodyState","source","steppingState","previousState","accumulator","step","timeStepVariable","clampedDelta","clamp","stepWorld","timestep","forEachRigidBody","body","translation","interpolationAlpha","onSleep","onWake","isSleeping","_events$onSleep","_events$onWake","setMatrix","compose","invertedWorldMatrix","meshType","lerp","slerp","drainCollisionEvents","handle1","handle2","started","source1","source2","collisionPayload1","collisionPayload2","contactPair","manifold","flipped","_source1$rigidBody$ev","_source1$rigidBody$ev2","_source2$rigidBody$ev","_source2$rigidBody$ev2","_source1$collider$eve","_source1$collider$eve2","_source2$collider$eve","_source2$collider$eve2","_source1$rigidBody$ev3","_source1$rigidBody$ev4","_source2$rigidBody$ev3","_source2$rigidBody$ev4","_source1$collider$eve3","_source1$collider$eve4","_source2$collider$eve3","_source2$collider$eve4","intersectionPair","_source1$rigidBody$ev5","_source1$rigidBody$ev6","_source2$rigidBody$ev5","_source2$rigidBody$ev6","_source1$collider$eve5","_source1$collider$eve6","_source2$collider$eve5","_source2$collider$eve6","_source1$rigidBody$ev7","_source1$rigidBody$ev8","_source2$rigidBody$ev7","_source2$rigidBody$ev8","_source1$collider$eve7","_source1$collider$eve8","_source2$collider$eve7","_source2$collider$eve8","drainContactForceEvents","event","_source1$rigidBody$ev9","_source1$rigidBody$ev10","_source2$rigidBody$ev9","_source2$rigidBody$ev10","_source1$collider$eve9","_source1$collider$eve10","_source2$collider$eve9","_source2$collider$eve10","collider1","collider2","totalForce","totalForceMagnitude","maxForceDirection","maxForceMagnitude","forEachActiveRigidBody","context","setWorld","physicsOptions","isPaused","isDebug","stepCallback","Provider","_extends","assign","bind","useForwardedRef","forwardedRef","defaultValue","innerRef","useImperativeInstance","createFn","destroyFn","dependencyList","getInstance","destroy","rigidBodyDescFromOptions","_options$canSleep","canSleep","createRigidBodyState","getMatrix","_meshType","matrix","immutableRigidBodyOptions","mutableRigidBodyOptions","gravityScale","rb","setGravityScale","additionalSolverIterations","setAdditionalSolverIterations","linearDamping","setLinearDamping","angularDamping","setAngularDamping","dominanceGroup","setDominanceGroup","enabledRotations","setEnabledRotations","enabledTranslations","setEnabledTranslations","lockRotations","lockTranslations","angularVelocity","setAngvel","linearVelocity","setLinvel","ccd","enableCcd","softCcdPrediction","setSoftCcdPrediction","setBodyType","mutableRigidBodyOptionKeys","setRigidBodyOptions","updateTranslations","useUpdateRigidBodyOptions","useRigidBodyEvents","eventHandlers","vec3","quat","euler","AnyCollider","name","rigidBodyContext","useRigidBodyContext","colliderRef","objectRef","immutablePropArray","removeCollider","mergedProps","CuboidCollider","forwardRef","displayName","RoundCuboidCollider","BallCollider","CapsuleCollider","HeightfieldCollider","TrimeshCollider","ConeCollider","RoundConeCollider","CylinderCollider","RoundCylinderCollider","ConvexHullCollider","_excluded$1","RigidBodyContext","transformState","objectProps","rigidBodyRef","mergedOptions","createRigidBody","removeRigidBody","contextValue","MeshCollider","_excluded","_excluded2","InstancedRigidBodies","_ref","rigidBodiesRef","instanceWrapperRef","instances","colliderNodes","rigidBodyProps","getInstancedMesh","firstChild","instancedMesh","instanceMatrix","setUsage","console","warn","applyInstancedState","getMatrixAt","setMatrixAt","needsUpdate","node","colliderIndex","useImpulseJoint","body1","body2","params","jointRef","newJoint","createImpulseJoint","joint","getImpulseJoint","removeImpulseJoint","useFixedJoint","body1Anchor","body1LocalFrame","body2Anchor","body2LocalFrame","JointData","useSphericalJoint","spherical","useRevoluteJoint","axis","limits","revolute","limitsEnabled","usePrismaticJoint","prismatic","useRopeJoint","vBody1Anchor","vBody2Anchor","rope","useSpringJoint","restLength","stiffness","damping","spring","interactionGroups","memberships","filters","bitmask","groups","flat","reduce","acc","layer"],"sources":["D:/Project Visual Studio Code/Portofolio/htmlv2/node_modules/@react-three/rapier/dist/react-three-rapier.esm.js"],"sourcesContent":["import { Vector3 as Vector3$1, Quaternion as Quaternion$1, ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferGeometry, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { suspend } from 'suspend-react';\nimport { mergeVertices } from 'three-stdlib';\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = v => {\n  if (Array.isArray(v)) {\n    return new Vector3$1(v[0], v[1], v[2]);\n  } else if (typeof v === \"number\") {\n    return new Vector3$1(v, v, v);\n  } else {\n    const threeVector3 = v;\n    return new Vector3$1(threeVector3.x, threeVector3.y, threeVector3.z);\n  }\n};\nconst quaternionToRapierQuaternion = v => {\n  if (Array.isArray(v)) {\n    return new Quaternion$1(v[0], v[1], v[2], v[3]);\n  } else {\n    return new Quaternion$1(v.x, v.y, v.z, v.w);\n  }\n};\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n  if (Array.isArray(v)) {\n    return v;\n  }\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef(undefined);\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\", \"softCcdPrediction\", \"ref\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice();\n\n  // Heightfield uses a vector\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  }\n\n  // Trimesh and convex scale the vertices\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  }\n\n  // Prepfill with some extra\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale);\n  // @ts-ignore\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setDensity(options.density);\n    return;\n  }\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n    collider.setMass(options.mass);\n    return;\n  }\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  activeCollisionTypes: (collider, value) => {\n    collider.setActiveCollisionTypes(value);\n  },\n  contactSkin: (collider, value) => {\n    collider.setContactSkin(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n  if (state) {\n    var _state$worldParent;\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n    _matrix4.copy(state.object.matrixWorld);\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n    _matrix4.decompose(_position, _rotation, _scale);\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider,\n        // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    });\n\n    // handle mass separately, because the assignments\n    // are exclusive.\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n      childColliderProps.push(colliderProps);\n    }\n  };\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n  return rest;\n};\n\n// Utils\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n};\n\n// External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\nconst useRapier = () => {\n  const rapier = useContext(rapierContext);\n  if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n  return rapier;\n};\n\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n\n// Internal hooks\n/**\n * @internal\n */\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n    mesh.geometry.dispose();\n    mesh.geometry = geometry;\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.get(instance, prop);\n    },\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return Reflect.set(instance, prop, value);\n    }\n  };\n  const proxy = new Proxy({}, handler);\n  const reset = () => {\n    instance = undefined;\n  };\n  const set = newInstance => {\n    instance = newInstance;\n  };\n\n  /**\n   * Return the proxy and a reset function\n   */\n  return {\n    proxy,\n    reset,\n    set\n  };\n};\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    allowedLinearError = 0.001,\n    predictionDistance = 0.002,\n    numSolverIterations = 4,\n    numAdditionalFrictionIterations = 4,\n    numInternalPgsIterations = 1,\n    minIslandSize = 128,\n    maxCcdSubsteps = 1,\n    contactNaturalFrequency = 30,\n    lengthUnit = 1\n  } = props;\n  const rapier = suspend(importRapier, [\"@react-thee/rapier\", importRapier]);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy,\n    set: setWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []);\n\n  // Update mutable props\n  useEffect(() => {\n    worldProxy.gravity = vector3ToRapierVector(gravity);\n    worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n    worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n    worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n    worldProxy.integrationParameters.normalizedAllowedLinearError = allowedLinearError;\n    worldProxy.integrationParameters.minIslandSize = minIslandSize;\n    worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n    worldProxy.integrationParameters.normalizedPredictionDistance = predictionDistance;\n    worldProxy.lengthUnit = lengthUnit;\n    worldProxy.integrationParameters.contact_natural_frequency = contactNaturalFrequency;\n  }, [worldProxy, ...gravity, numSolverIterations, numAdditionalFrictionIterations, numInternalPgsIterations, allowedLinearError, minIslandSize, maxCcdSubsteps, predictionDistance, lengthUnit, contactNaturalFrequency]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n    const timeStepVariable = timeStep === \"vary\";\n\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue);\n\n      // Trigger afterStep callbacks\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep;\n\n    // Update meshes\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n        state.isSleeping = rigidBody.isSleeping();\n      }\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      }\n\n      // New states\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n        // Apply previous tick position\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      }\n\n      // Get new position\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2);\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n\n          /* Collider events */\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      }\n\n      // Sensor Intersections\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2());\n\n      // Collision Events\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    setWorld: world => {\n      setWorldProxy(world);\n    },\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\n// Need to catch the case where forwardedRef is a function... how to do that?\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue);\n\n  // Update the forwarded ref when the inner ref changes\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n    return forwardedRef;\n  }\n  return innerRef;\n};\n\n/**\n * Initiate an instance and return a safe getter\n */\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef(undefined);\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n    const destroy = () => destroyFn(instance);\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type);\n\n  // Apply immutable options\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  additionalSolverIterations(rb, value) {\n    rb.setAdditionalSolverIterations(value);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  softCcdPrediction: (rb, value) => {\n    rb.setSoftCcdPrediction(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n  const state = states.get(rigidBody.handle);\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(props.ref);\n  const objectRef = useRef(null);\n\n  // We spread the props out here to make sure that the ref is updated when the props change.\n  const immutablePropArray = immutableColliderOptions.flatMap(key =>\n  // Array.isArray(props[key]) ? [...props[key]] : props[key]\n  Array.isArray(props[key]) ? props[key] : [props[key]]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n    if (typeof props.ref == \"function\") {\n      props.ref(collider);\n    }\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n});\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst _excluded$1 = [\"ref\", \"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo(props => {\n  const {\n      ref,\n      children,\n      type,\n      position,\n      rotation,\n      scale,\n      quaternion,\n      transformState\n    } = props,\n    objectProps = _objectWithoutProperties(props, _excluded$1);\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(ref);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions);\n\n  // Provide a way to eagerly create rigidbody\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n    if (typeof ref === \"function\") {\n      ref(rigidBody);\n    }\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray);\n\n  // Only provide a object state after the ref has been set\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n});\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"ref\"],\n  _excluded2 = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo(_ref => {\n  let {\n      ref\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const rigidBodiesRef = useForwardedRef(ref, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n  const {\n      // instanced props\n      children,\n      instances,\n      colliderNodes = [],\n      // wrapper object props\n      position,\n      rotation,\n      quaternion,\n      scale\n\n      // rigid body specific props, and r3f-object props\n    } = props,\n    rigidBodyProps = _objectWithoutProperties(props, _excluded2);\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n    return undefined;\n  };\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []);\n\n  // Update the RigidBodyStates whenever the instances change\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n    return state;\n  };\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => {\n      rigidBodiesRef.current[index] = body;\n    },\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n});\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef(undefined);\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */\nconst useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */\nconst useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping]) => {\n  const {\n    rapier\n  } = useRapier();\n  const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n  const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n  const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useRopeJoint, useSphericalJoint, useSpringJoint, vec3 };\n"],"mappings":"AAAA,SAASA,OAAO,IAAIC,SAAS,EAAEC,UAAU,IAAIC,YAAY,EAAEC,YAAY,EAAEC,YAAY,EAAEC,UAAU,EAAEC,aAAa,QAAQ,2BAA2B;AACnJ,SAASC,sBAAsB,EAAEC,QAAQ,IAAIC,cAAc,EAAEC,SAAS,IAAIC,eAAe,QAAQ,2BAA2B;AAC5H,SAASC,QAAQ,EAAEC,QAAQ,QAAQ,oBAAoB;AACvD,OAAOC,KAAK,IAAIC,MAAM,EAAEC,SAAS,EAAEC,IAAI,EAAEC,OAAO,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,aAAa,EAAEC,WAAW,EAAEC,QAAQ,QAAQ,OAAO;AAC3H,SAAStB,UAAU,EAAEuB,KAAK,EAAEzB,OAAO,EAAE0B,QAAQ,EAAEC,OAAO,EAAEC,cAAc,EAAEC,eAAe,EAAEC,SAAS,EAAEC,gBAAgB,QAAQ,OAAO;AACnI,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,aAAa,QAAQ,cAAc;AAE5C,SAASC,YAAYA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAC1B,IAAI,QAAQ,IAAI,OAAOD,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EACxC,IAAIE,CAAC,GAAGF,CAAC,CAACG,MAAM,CAACC,WAAW,CAAC;EAC7B,IAAI,KAAK,CAAC,KAAKF,CAAC,EAAE;IAChB,IAAIG,CAAC,GAAGH,CAAC,CAACI,IAAI,CAACN,CAAC,EAAEC,CAAC,IAAI,SAAS,CAAC;IACjC,IAAI,QAAQ,IAAI,OAAOI,CAAC,EAAE,OAAOA,CAAC;IAClC,MAAM,IAAIE,SAAS,CAAC,8CAA8C,CAAC;EACrE;EACA,OAAO,CAAC,QAAQ,KAAKN,CAAC,GAAGO,MAAM,GAAGC,MAAM,EAAET,CAAC,CAAC;AAC9C;AAEA,SAASU,cAAcA,CAACV,CAAC,EAAE;EACzB,IAAIK,CAAC,GAAGN,YAAY,CAACC,CAAC,EAAE,QAAQ,CAAC;EACjC,OAAO,QAAQ,IAAI,OAAOK,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAC1C;AAEA,SAASM,eAAeA,CAACT,CAAC,EAAED,CAAC,EAAED,CAAC,EAAE;EAChC,OAAO,CAACC,CAAC,GAAGS,cAAc,CAACT,CAAC,CAAC,KAAKC,CAAC,GAAGU,MAAM,CAACC,cAAc,CAACX,CAAC,EAAED,CAAC,EAAE;IAChEa,KAAK,EAAEd,CAAC;IACRe,UAAU,EAAE,CAAC,CAAC;IACdC,YAAY,EAAE,CAAC,CAAC;IAChBC,QAAQ,EAAE,CAAC;EACb,CAAC,CAAC,GAAGf,CAAC,CAACD,CAAC,CAAC,GAAGD,CAAC,EAAEE,CAAC;AAClB;AAEA,SAASgB,OAAOA,CAAChB,CAAC,EAAED,CAAC,EAAE;EACrB,IAAID,CAAC,GAAGY,MAAM,CAACO,IAAI,CAACjB,CAAC,CAAC;EACtB,IAAIU,MAAM,CAACQ,qBAAqB,EAAE;IAChC,IAAIC,CAAC,GAAGT,MAAM,CAACQ,qBAAqB,CAAClB,CAAC,CAAC;IACvCD,CAAC,KAAKoB,CAAC,GAAGA,CAAC,CAACC,MAAM,CAAC,UAAUrB,CAAC,EAAE;MAC9B,OAAOW,MAAM,CAACW,wBAAwB,CAACrB,CAAC,EAAED,CAAC,CAAC,CAACc,UAAU;IACzD,CAAC,CAAC,CAAC,EAAEf,CAAC,CAACwB,IAAI,CAACC,KAAK,CAACzB,CAAC,EAAEqB,CAAC,CAAC;EACzB;EACA,OAAOrB,CAAC;AACV;AACA,SAAS0B,cAAcA,CAACxB,CAAC,EAAE;EACzB,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,SAAS,CAACC,MAAM,EAAE3B,CAAC,EAAE,EAAE;IACzC,IAAID,CAAC,GAAG,IAAI,IAAI2B,SAAS,CAAC1B,CAAC,CAAC,GAAG0B,SAAS,CAAC1B,CAAC,CAAC,GAAG,CAAC,CAAC;IAChDA,CAAC,GAAG,CAAC,GAAGiB,OAAO,CAACN,MAAM,CAACZ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC6B,OAAO,CAAC,UAAU5B,CAAC,EAAE;MAClDU,eAAe,CAACT,CAAC,EAAED,CAAC,EAAED,CAAC,CAACC,CAAC,CAAC,CAAC;IAC7B,CAAC,CAAC,GAAGW,MAAM,CAACkB,yBAAyB,GAAGlB,MAAM,CAACmB,gBAAgB,CAAC7B,CAAC,EAAEU,MAAM,CAACkB,yBAAyB,CAAC9B,CAAC,CAAC,CAAC,GAAGkB,OAAO,CAACN,MAAM,CAACZ,CAAC,CAAC,CAAC,CAAC6B,OAAO,CAAC,UAAU5B,CAAC,EAAE;MAChJW,MAAM,CAACC,cAAc,CAACX,CAAC,EAAED,CAAC,EAAEW,MAAM,CAACW,wBAAwB,CAACvB,CAAC,EAAEC,CAAC,CAAC,CAAC;IACpE,CAAC,CAAC;EACJ;EACA,OAAOC,CAAC;AACV;AAEA,MAAM8B,WAAW,GAAG,IAAIjE,UAAU,CAAC,CAAC;AACpC,IAAIuB,KAAK,CAAC,CAAC;AACX,MAAM2C,QAAQ,GAAG,IAAIpE,OAAO,CAAC,CAAC;AAC9B,IAAI0B,QAAQ,CAAC,CAAC;AACd,MAAM2C,QAAQ,GAAG,IAAI1C,OAAO,CAAC,CAAC;AAC9B,MAAM2C,SAAS,GAAG,IAAItE,OAAO,CAAC,CAAC;AAC/B,MAAMuE,SAAS,GAAG,IAAIrE,UAAU,CAAC,CAAC;AAClC,MAAMsE,MAAM,GAAG,IAAIxE,OAAO,CAAC,CAAC;AAE5B,MAAMyE,oBAAoB,GAAGC,GAAG,IAAI;EAClC,MAAM,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGH,GAAG;EACrB,OAAO,IAAI1E,OAAO,CAAC2E,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;AAC7B,CAAC;AACD,MAAMC,4BAA4B,GAAGA,CAAC;EACpCH,CAAC;EACDC,CAAC;EACDC,CAAC;EACDE;AACF,CAAC,KAAKZ,WAAW,CAACa,GAAG,CAACL,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,CAAC,CAAC;AACjC,MAAME,qBAAqB,GAAGC,CAAC,IAAI;EACjC,IAAIC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,EAAE;IACpB,OAAO,IAAIjF,SAAS,CAACiF,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC;EACxC,CAAC,MAAM,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;IAChC,OAAO,IAAIjF,SAAS,CAACiF,CAAC,EAAEA,CAAC,EAAEA,CAAC,CAAC;EAC/B,CAAC,MAAM;IACL,MAAMG,YAAY,GAAGH,CAAC;IACtB,OAAO,IAAIjF,SAAS,CAACoF,YAAY,CAACV,CAAC,EAAEU,YAAY,CAACT,CAAC,EAAES,YAAY,CAACR,CAAC,CAAC;EACtE;AACF,CAAC;AACD,MAAMS,4BAA4B,GAAGJ,CAAC,IAAI;EACxC,IAAIC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,EAAE;IACpB,OAAO,IAAI/E,YAAY,CAAC+E,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC;EACjD,CAAC,MAAM;IACL,OAAO,IAAI/E,YAAY,CAAC+E,CAAC,CAACP,CAAC,EAAEO,CAAC,CAACN,CAAC,EAAEM,CAAC,CAACL,CAAC,EAAEK,CAAC,CAACH,CAAC,CAAC;EAC7C;AACF,CAAC;AACD,MAAMQ,gBAAgB,GAAG;EACvBC,KAAK,EAAE,CAAC;EACRC,OAAO,EAAE,CAAC;EACVC,iBAAiB,EAAE,CAAC;EACpBC,iBAAiB,EAAE;AACrB,CAAC;AACD,MAAMC,uBAAuB,GAAGC,IAAI,IAAIN,gBAAgB,CAACM,IAAI,CAAC;AAC9D,MAAMC,aAAa,GAAGA,CAACC,QAAQ,EAAEC,KAAK,KAAK;EACzC,MAAMC,WAAW,GAAGd,KAAK,CAACe,IAAI,CAACH,QAAQ,CAAC;EACxC,KAAK,IAAIvD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuD,QAAQ,CAAChC,MAAM,GAAG,CAAC,EAAEvB,CAAC,EAAE,EAAE;IAC5CyD,WAAW,CAACzD,CAAC,GAAG,CAAC,CAAC,IAAIwD,KAAK,CAACrB,CAAC;IAC7BsB,WAAW,CAACzD,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIwD,KAAK,CAACpB,CAAC;IACjCqB,WAAW,CAACzD,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,IAAIwD,KAAK,CAACnB,CAAC;EACnC;EACA,OAAOoB,WAAW;AACpB,CAAC;AACD,MAAME,aAAa,GAAGjB,CAAC,IAAI;EACzB,IAAI,CAACA,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;EAClB,IAAIA,CAAC,YAAYhF,UAAU,EAAE;IAC3B,OAAO,CAACgF,CAAC,CAACP,CAAC,EAAEO,CAAC,CAACN,CAAC,EAAEM,CAAC,CAACL,CAAC,EAAEK,CAAC,CAACH,CAAC,CAAC;EAC7B;EACA,IAAIG,CAAC,YAAYlF,OAAO,IAAIkF,CAAC,YAAYzD,KAAK,EAAE;IAC9C,OAAO,CAACyD,CAAC,CAACP,CAAC,EAAEO,CAAC,CAACN,CAAC,EAAEM,CAAC,CAACL,CAAC,CAAC;EACxB;EACA,IAAIM,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,EAAE;IACpB,OAAOA,CAAC;EACV;EACA,OAAO,CAACA,CAAC,CAAC;AACZ,CAAC;AACD,SAASkB,QAAQA,CAACC,YAAY,EAAE;EAC9B,MAAMC,GAAG,GAAGtF,MAAM,CAACuF,SAAS,CAAC;EAC7B,IAAID,GAAG,CAACE,OAAO,KAAKD,SAAS,EAAE;IAC7BD,GAAG,CAACE,OAAO,GAAG;MACZvD,KAAK,EAAE,OAAOoD,YAAY,KAAK,UAAU,GAAGA,YAAY,CAAC,CAAC,GAAGA;IAC/D,CAAC;EACH;EACA,OAAOC,GAAG,CAACE,OAAO,CAACvD,KAAK;AAC1B;AAEA,MAAMwD,MAAM,GAAGC,QAAQ,IAAI;EACzB,MAAMC,EAAE,GAAG3F,MAAM,CAAC0F,QAAQ,CAAC;EAC3B,MAAME,GAAG,GAAG5F,MAAM,CAAC,CAAC,CAAC;EACrB,MAAM6F,SAAS,GAAG7F,MAAM,CAAC,CAAC,CAAC;EAC3BC,SAAS,CAAC,MAAM;IACd0F,EAAE,CAACH,OAAO,GAAGE,QAAQ;EACvB,CAAC,EAAE,CAACA,QAAQ,CAAC,CAAC;EACdzF,SAAS,CAAC,MAAM;IACd,MAAM6F,IAAI,GAAGA,CAAA,KAAM;MACjB,MAAMC,GAAG,GAAGC,WAAW,CAACD,GAAG,CAAC,CAAC;MAC7B,MAAME,KAAK,GAAGF,GAAG,GAAGF,SAAS,CAACL,OAAO;MACrCI,GAAG,CAACJ,OAAO,GAAGU,qBAAqB,CAACJ,IAAI,CAAC;MACzCH,EAAE,CAACH,OAAO,CAACS,KAAK,GAAG,IAAI,CAAC;MACxBJ,SAAS,CAACL,OAAO,GAAGO,GAAG;IACzB,CAAC;IACDH,GAAG,CAACJ,OAAO,GAAGU,qBAAqB,CAACJ,IAAI,CAAC;IACzC,OAAO,MAAMK,oBAAoB,CAACP,GAAG,CAACJ,OAAO,CAAC;EAChD,CAAC,EAAE,EAAE,CAAC;AACR,CAAC;AAED,MAAMY,eAAe,GAAGA,CAAC;EACvBC,MAAM;EACNC;AACF,CAAC,KAAK;EACJzG,QAAQ,CAAC,CAAC0G,CAAC,EAAEC,EAAE,KAAK;IAClBH,MAAM,CAACG,EAAE,CAAC;EACZ,CAAC,EAAEF,cAAc,CAAC;EAClB,OAAO,IAAI;AACb,CAAC;AACD,MAAMG,UAAU,GAAGA,CAAC;EAClBJ;AACF,CAAC,KAAK;EACJZ,MAAM,CAACe,EAAE,IAAI;IACXH,MAAM,CAACG,EAAE,CAAC;EACZ,CAAC,CAAC;EACF,OAAO,IAAI;AACb,CAAC;AACD,MAAME,YAAY,GAAGA,CAAC;EACpBL,MAAM;EACNxB,IAAI;EACJyB;AACF,CAAC,KAAK;EACJ,OAAOzB,IAAI,KAAK,aAAa,GAAG,aAAa9E,KAAK,CAAC4G,aAAa,CAACF,UAAU,EAAE;IAC3EJ,MAAM,EAAEA;EACV,CAAC,CAAC,GAAG,aAAatG,KAAK,CAAC4G,aAAa,CAACP,eAAe,EAAE;IACrDC,MAAM,EAAEA,MAAM;IACdC,cAAc,EAAEA;EAClB,CAAC,CAAC;AACJ,CAAC;AACD,IAAIM,cAAc,GAAG,aAAa1G,IAAI,CAACwG,YAAY,CAAC;AAEpD,SAASG,6BAA6BA,CAACzF,CAAC,EAAEC,CAAC,EAAE;EAC3C,IAAI,IAAI,IAAID,CAAC,EAAE,OAAO,CAAC,CAAC;EACxB,IAAID,CAAC,GAAG,CAAC,CAAC;EACV,KAAK,IAAI2F,CAAC,IAAI1F,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC2F,cAAc,CAACtF,IAAI,CAACL,CAAC,EAAE0F,CAAC,CAAC,EAAE;IACjD,IAAI,CAAC,CAAC,KAAKzF,CAAC,CAAC2F,OAAO,CAACF,CAAC,CAAC,EAAE;IACzB3F,CAAC,CAAC2F,CAAC,CAAC,GAAG1F,CAAC,CAAC0F,CAAC,CAAC;EACb;EACA,OAAO3F,CAAC;AACV;AAEA,SAAS8F,wBAAwBA,CAAC5F,CAAC,EAAEF,CAAC,EAAE;EACtC,IAAI,IAAI,IAAIE,CAAC,EAAE,OAAO,CAAC,CAAC;EACxB,IAAImB,CAAC;IACHpB,CAAC;IACDI,CAAC,GAAGqF,6BAA6B,CAACxF,CAAC,EAAEF,CAAC,CAAC;EACzC,IAAIY,MAAM,CAACQ,qBAAqB,EAAE;IAChC,IAAIuE,CAAC,GAAG/E,MAAM,CAACQ,qBAAqB,CAAClB,CAAC,CAAC;IACvC,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0F,CAAC,CAAC/D,MAAM,EAAE3B,CAAC,EAAE,EAAEoB,CAAC,GAAGsE,CAAC,CAAC1F,CAAC,CAAC,EAAE,CAAC,CAAC,KAAKD,CAAC,CAAC6F,OAAO,CAACxE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC0E,oBAAoB,CAACzF,IAAI,CAACJ,CAAC,EAAEmB,CAAC,CAAC,KAAKhB,CAAC,CAACgB,CAAC,CAAC,GAAGnB,CAAC,CAACmB,CAAC,CAAC,CAAC;EACrH;EACA,OAAOhB,CAAC;AACV;AAEA,MAAM2F,WAAW,GAAG,CAAC,MAAM,EAAE,eAAe,EAAE,gBAAgB,EAAE,MAAM,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,qBAAqB,EAAE,oBAAoB,EAAE,gBAAgB,EAAE,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,cAAc,EAAE,mBAAmB,EAAE,KAAK,CAAC;AACxP,MAAMC,iBAAiB,GAAGA,CAACC,KAAK,EAAEC,IAAI,EAAEtC,KAAK,KAAK;EAChD,MAAMuC,OAAO,GAAGD,IAAI,CAACE,KAAK,CAAC,CAAC;;EAE5B;EACA,IAAIH,KAAK,KAAK,aAAa,EAAE;IAC3B,MAAMI,CAAC,GAAGF,OAAO,CAAC,CAAC,CAAC;IACpBE,CAAC,CAAC9D,CAAC,IAAIqB,KAAK,CAACrB,CAAC;IACd8D,CAAC,CAAC9D,CAAC,IAAIqB,KAAK,CAACpB,CAAC;IACd6D,CAAC,CAAC9D,CAAC,IAAIqB,KAAK,CAACnB,CAAC;IACd,OAAO0D,OAAO;EAChB;;EAEA;EACA,IAAIF,KAAK,KAAK,SAAS,IAAIA,KAAK,KAAK,YAAY,EAAE;IACjDE,OAAO,CAAC,CAAC,CAAC,GAAGzC,aAAa,CAACyC,OAAO,CAAC,CAAC,CAAC,EAAEvC,KAAK,CAAC;IAC7C,OAAOuC,OAAO;EAChB;;EAEA;EACA,MAAMG,UAAU,GAAG,CAAC1C,KAAK,CAACrB,CAAC,EAAEqB,KAAK,CAACpB,CAAC,EAAEoB,KAAK,CAACnB,CAAC,EAAEmB,KAAK,CAACrB,CAAC,EAAEqB,KAAK,CAACrB,CAAC,CAAC;EAChE,OAAO4D,OAAO,CAACI,GAAG,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAKH,UAAU,CAACG,KAAK,CAAC,GAAGD,GAAG,CAAC;AAC7D,CAAC;AACD,MAAME,yBAAyB,GAAGA,CAACC,OAAO,EAAEC,KAAK,EAAEhD,KAAK,EAAEiD,YAAY,KAAK;EACzE,MAAMC,UAAU,GAAGd,iBAAiB,CAACW,OAAO,CAACV,KAAK,EAAEU,OAAO,CAACT,IAAI,EAAEtC,KAAK,CAAC;EACxE;EACA,MAAMmD,IAAI,GAAG9I,YAAY,CAAC0I,OAAO,CAACV,KAAK,CAAC,CAAC,GAAGa,UAAU,CAAC;EACvD,OAAOF,KAAK,CAACI,cAAc,CAACD,IAAI,EAAEF,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAAC,CAAC,CAAC;AAC/G,CAAC;AACD,MAAMI,wBAAwB,GAAG,CAAC,OAAO,EAAE,MAAM,CAAC;AAClD,MAAMC,2BAA2B,GAAG,6EAA6E;AACjH,MAAMC,sBAAsB,GAAGA,CAACC,QAAQ,EAAET,OAAO,KAAK;EACpD,IAAIA,OAAO,CAACU,OAAO,KAAKlD,SAAS,EAAE;IACjC,IAAIwC,OAAO,CAACW,IAAI,KAAKnD,SAAS,IAAIwC,OAAO,CAACY,cAAc,KAAKpD,SAAS,EAAE;MACtE,MAAM,IAAIqD,KAAK,CAACN,2BAA2B,CAAC;IAC9C;IACAE,QAAQ,CAACK,UAAU,CAACd,OAAO,CAACU,OAAO,CAAC;IACpC;EACF;EACA,IAAIV,OAAO,CAACW,IAAI,KAAKnD,SAAS,EAAE;IAC9B,IAAIwC,OAAO,CAACY,cAAc,KAAKpD,SAAS,EAAE;MACxC,MAAM,IAAIqD,KAAK,CAACN,2BAA2B,CAAC;IAC9C;IACAE,QAAQ,CAACM,OAAO,CAACf,OAAO,CAACW,IAAI,CAAC;IAC9B;EACF;EACA,IAAIX,OAAO,CAACY,cAAc,KAAKpD,SAAS,EAAE;IACxCiD,QAAQ,CAACO,iBAAiB,CAAChB,OAAO,CAACY,cAAc,CAACD,IAAI,EAAEX,OAAO,CAACY,cAAc,CAACK,YAAY,EAAEjB,OAAO,CAACY,cAAc,CAACM,uBAAuB,EAAElB,OAAO,CAACY,cAAc,CAACO,wBAAwB,CAAC;EAC/L;AACF,CAAC;AACD,MAAMC,sBAAsB,GAAG;EAC7BC,MAAM,EAAEA,CAACZ,QAAQ,EAAEvG,KAAK,KAAK;IAC3BuG,QAAQ,CAACa,SAAS,CAACpH,KAAK,CAAC;EAC3B,CAAC;EACDqH,eAAe,EAAEA,CAACd,QAAQ,EAAEvG,KAAK,KAAK;IACpCuG,QAAQ,CAACe,kBAAkB,CAACtH,KAAK,CAAC;EACpC,CAAC;EACDuH,YAAY,EAAEA,CAAChB,QAAQ,EAAEvG,KAAK,KAAK;IACjCuG,QAAQ,CAACiB,eAAe,CAACxH,KAAK,CAAC;EACjC,CAAC;EACDyH,QAAQ,EAAEA,CAAClB,QAAQ,EAAEvG,KAAK,KAAK;IAC7BuG,QAAQ,CAACmB,WAAW,CAAC1H,KAAK,CAAC;EAC7B,CAAC;EACD2H,mBAAmB,EAAEA,CAACpB,QAAQ,EAAEvG,KAAK,KAAK;IACxCuG,QAAQ,CAACqB,sBAAsB,CAAC5H,KAAK,CAAC;EACxC,CAAC;EACD6H,WAAW,EAAEA,CAACtB,QAAQ,EAAEvG,KAAK,KAAK;IAChCuG,QAAQ,CAACuB,cAAc,CAAC9H,KAAK,CAAC;EAChC,CAAC;EACD+H,sBAAsB,EAAEA,CAACxB,QAAQ,EAAEvG,KAAK,KAAK;IAC3CuG,QAAQ,CAACyB,yBAAyB,CAAChI,KAAK,CAAC;EAC3C,CAAC;EACDiI,oBAAoB,EAAEA,CAAC1B,QAAQ,EAAEvG,KAAK,KAAK;IACzCuG,QAAQ,CAAC2B,uBAAuB,CAAClI,KAAK,CAAC;EACzC,CAAC;EACDmI,WAAW,EAAEA,CAAC5B,QAAQ,EAAEvG,KAAK,KAAK;IAChCuG,QAAQ,CAAC6B,cAAc,CAACpI,KAAK,CAAC;EAChC,CAAC;EACD;EACAqI,UAAU,EAAEA,CAAA,KAAM,CAAC,CAAC;EACpBC,QAAQ,EAAEA,CAAA,KAAM,CAAC,CAAC;EAClBC,QAAQ,EAAEA,CAAA,KAAM,CAAC,CAAC;EAClBxF,KAAK,EAAEA,CAAA,KAAM,CAAC;AAChB,CAAC;AACD,MAAMyF,yBAAyB,GAAG1I,MAAM,CAACO,IAAI,CAAC6G,sBAAsB,CAAC;AACrE,MAAMuB,kBAAkB,GAAGA,CAAClC,QAAQ,EAAET,OAAO,EAAE4C,MAAM,KAAK;EACxD,MAAMC,KAAK,GAAGD,MAAM,CAACE,GAAG,CAACrC,QAAQ,CAACsC,MAAM,CAAC;EACzC,IAAIF,KAAK,EAAE;IACT,IAAIG,kBAAkB;IACtB;IACA,MAAMC,gBAAgB,GAAGJ,KAAK,CAACK,MAAM,CAACC,MAAM,CAACC,aAAa,CAAC/H,QAAQ,CAAC;IACpE,MAAMgI,yBAAyB,GAAG,CAACL,kBAAkB,GAAGH,KAAK,CAACS,WAAW,MAAM,IAAI,IAAIN,kBAAkB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,kBAAkB,CAACO,WAAW,CAACC,KAAK,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;IAC/KZ,KAAK,CAACK,MAAM,CAACQ,iBAAiB,CAAC,IAAI,EAAE,KAAK,CAAC;IAC3CpI,QAAQ,CAACqI,IAAI,CAACd,KAAK,CAACK,MAAM,CAACK,WAAW,CAAC;IACvC,IAAIF,yBAAyB,EAAE;MAC7B/H,QAAQ,CAACsI,WAAW,CAACP,yBAAyB,CAAC;IACjD;IACA/H,QAAQ,CAACuI,SAAS,CAACtI,SAAS,EAAEC,SAAS,EAAEC,MAAM,CAAC;IAChD,IAAIgF,QAAQ,CAAC0C,MAAM,CAAC,CAAC,EAAE;MACrB1C,QAAQ,CAACqD,uBAAuB,CAAC;QAC/BlI,CAAC,EAAEL,SAAS,CAACK,CAAC,GAAGqH,gBAAgB,CAACrH,CAAC;QACnCC,CAAC,EAAEN,SAAS,CAACM,CAAC,GAAGoH,gBAAgB,CAACpH,CAAC;QACnCC,CAAC,EAAEP,SAAS,CAACO,CAAC,GAAGmH,gBAAgB,CAACnH;MACpC,CAAC,CAAC;MACF2E,QAAQ,CAACsD,oBAAoB,CAACvI,SAAS,CAAC;IAC1C,CAAC,MAAM;MACLiF,QAAQ,CAACuD,cAAc,CAAC;QACtBpI,CAAC,EAAEL,SAAS,CAACK,CAAC,GAAGqH,gBAAgB,CAACrH,CAAC;QACnCC,CAAC,EAAEN,SAAS,CAACM,CAAC,GAAGoH,gBAAgB,CAACpH,CAAC;QACnCC,CAAC,EAAEP,SAAS,CAACO,CAAC,GAAGmH,gBAAgB,CAACnH;MACpC,CAAC,CAAC;MACF2E,QAAQ,CAACwD,WAAW,CAACzI,SAAS,CAAC;IACjC;IACAkH,yBAAyB,CAACzH,OAAO,CAACiJ,GAAG,IAAI;MACvC,IAAIA,GAAG,IAAIlE,OAAO,EAAE;QAClB,MAAMmE,MAAM,GAAGnE,OAAO,CAACkE,GAAG,CAAC;QAC3B9C,sBAAsB,CAAC8C,GAAG,CAAC,CAACzD,QAAQ;QACpC;QACA0D,MAAM,EAAEnE,OAAO,CAAC;MAClB;IACF,CAAC,CAAC;;IAEF;IACA;IACAQ,sBAAsB,CAACC,QAAQ,EAAET,OAAO,CAAC;EAC3C;AACF,CAAC;AACD,MAAMoE,wBAAwB,GAAGA,CAACC,WAAW,EAAEC,KAAK,EAAE1B,MAAM,KAAK;EAC/D;EACA,MAAM2B,uBAAuB,GAAGnM,OAAO,CAAC,MAAMsK,yBAAyB,CAAC8B,OAAO,CAACN,GAAG,IAAI;IACrF,OAAO9G,aAAa,CAACkH,KAAK,CAACJ,GAAG,CAAC,CAAC;EAClC,CAAC,CAAC,EAAE,CAACI,KAAK,CAAC,CAAC;EACZpM,SAAS,CAAC,MAAM;IACd,MAAMuI,QAAQ,GAAG4D,WAAW,CAAC,CAAC;IAC9B1B,kBAAkB,CAAClC,QAAQ,EAAE6D,KAAK,EAAE1B,MAAM,CAAC;EAC7C,CAAC,EAAE,CAAC,GAAG2B,uBAAuB,EAAEF,WAAW,CAAC,CAAC;AAC/C,CAAC;AACD,MAAMI,qBAAqB,GAAGC,KAAK,IAAI;EACrC,IAAIC,IAAI,GAAG,KAAK;EAChBD,KAAK,CAACE,iBAAiB,CAACC,CAAC,IAAI;IAC3B,IAAIA,CAAC,CAACC,QAAQ,CAACC,YAAY,KAAK,cAAc,EAAEJ,IAAI,GAAG,IAAI;EAC7D,CAAC,CAAC;EACF,OAAOA,IAAI;AACb,CAAC;AACD,MAAMK,mBAAmB,GAAGA,CAACvE,QAAQ,EAAEyC,MAAM,EAAE+B,eAAe,KAAK;EACjE,OAAO;IACLxE,QAAQ;IACR6C,WAAW,EAAE2B,eAAe,IAAIzH,SAAS;IACzC0F;EACF,CAAC;AACH,CAAC;AACD,MAAMgC,eAAe,GAAG;EACtBC,MAAM,EAAE,QAAQ;EAChBC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE,YAAY;EAClBC,OAAO,EAAE;AACX,CAAC;AACD,MAAMC,+BAA+B,GAAGA,CAAC;EACvCrC,MAAM;EACNsC,mBAAmB,EAAEC,oBAAoB,GAAG,IAAI;EAChDzF;AACF,CAAC,KAAK;EACJ,MAAM0F,kBAAkB,GAAG,EAAE;EAC7BxC,MAAM,CAACQ,iBAAiB,CAAC,IAAI,EAAE,KAAK,CAAC;EACrC,MAAMiC,yBAAyB,GAAGzC,MAAM,CAACK,WAAW,CAACC,KAAK,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;EACrE,MAAMmC,iBAAiB,GAAGlB,KAAK,IAAI;IACjC,IAAI,QAAQ,IAAIA,KAAK,EAAE;MACrB,IAAIe,oBAAoB,IAAIhB,qBAAqB,CAACC,KAAK,CAAC,EAAE;MAC1D,MAAMmB,UAAU,GAAGnB,KAAK,CAACtB,aAAa,CAAC3H,MAAM,CAAC;MAC9C,MAAM6D,KAAK,GAAG4F,eAAe,CAAClF,OAAO,CAAC8F,SAAS,IAAI,QAAQ,CAAC;MAC5DpB,KAAK,CAAChB,iBAAiB,CAAC,IAAI,EAAE,KAAK,CAAC;MACpCpI,QAAQ,CAACqI,IAAI,CAACe,KAAK,CAACnB,WAAW,CAAC,CAACK,WAAW,CAAC+B,yBAAyB,CAAC,CAAC9B,SAAS,CAACtI,SAAS,EAAEC,SAAS,EAAEC,MAAM,CAAC;MAC/G,MAAMsK,aAAa,GAAG,IAAIrN,KAAK,CAAC,CAAC,CAACsN,iBAAiB,CAACxK,SAAS,EAAE,KAAK,CAAC;MACrE,MAAM;QACJyK;MACF,CAAC,GAAGvB,KAAK;MACT,MAAM;QACJnF,IAAI;QACJ2G;MACF,CAAC,GAAGC,2BAA2B,CAACF,QAAQ,EAAEjG,OAAO,CAAC8F,SAAS,IAAI,QAAQ,CAAC;MACxE,MAAMM,aAAa,GAAGtL,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEuL,8BAA8B,CAACrG,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;QACpGT,IAAI,EAAEA,IAAI;QACVD,KAAK,EAAEA,KAAK;QACZmD,QAAQ,EAAE,CAACsD,aAAa,CAACnK,CAAC,EAAEmK,aAAa,CAAClK,CAAC,EAAEkK,aAAa,CAACjK,CAAC,CAAC;QAC7D0G,QAAQ,EAAE,CAACjH,SAAS,CAACK,CAAC,GAAGsK,MAAM,CAACtK,CAAC,GAAGiK,UAAU,CAACjK,CAAC,EAAEL,SAAS,CAACM,CAAC,GAAGqK,MAAM,CAACrK,CAAC,GAAGgK,UAAU,CAAChK,CAAC,EAAEN,SAAS,CAACO,CAAC,GAAGoK,MAAM,CAACpK,CAAC,GAAG+J,UAAU,CAAC/J,CAAC,CAAC;QAC/HmB,KAAK,EAAE,CAAC4I,UAAU,CAACjK,CAAC,EAAEiK,UAAU,CAAChK,CAAC,EAAEgK,UAAU,CAAC/J,CAAC;MAClD,CAAC,CAAC;MACF4J,kBAAkB,CAAC9K,IAAI,CAACwL,aAAa,CAAC;IACxC;EACF,CAAC;EACD,IAAIpG,OAAO,CAACsG,gBAAgB,EAAE;IAC5BpD,MAAM,CAACqD,QAAQ,CAACX,iBAAiB,CAAC;EACpC,CAAC,MAAM;IACL1C,MAAM,CAACsD,eAAe,CAACZ,iBAAiB,CAAC;EAC3C;EACA,OAAOF,kBAAkB;AAC3B,CAAC;AACD,MAAMS,2BAA2B,GAAGA,CAACF,QAAQ,EAAEH,SAAS,KAAK;EAC3D,QAAQA,SAAS;IACf,KAAK,QAAQ;MACX;QACEG,QAAQ,CAACQ,kBAAkB,CAAC,CAAC;QAC7B,MAAM;UACJC;QACF,CAAC,GAAGT,QAAQ;QACZ,MAAMU,IAAI,GAAGD,WAAW,CAACE,OAAO,CAAC,IAAI3P,OAAO,CAAC,CAAC,CAAC;QAC/C,OAAO;UACLsI,IAAI,EAAE,CAACoH,IAAI,CAAC/K,CAAC,GAAG,CAAC,EAAE+K,IAAI,CAAC9K,CAAC,GAAG,CAAC,EAAE8K,IAAI,CAAC7K,CAAC,GAAG,CAAC,CAAC;UAC1CoK,MAAM,EAAEQ,WAAW,CAACG,SAAS,CAAC,IAAI5P,OAAO,CAAC,CAAC;QAC7C,CAAC;MACH;IACF,KAAK,MAAM;MACT;QACEgP,QAAQ,CAACa,qBAAqB,CAAC,CAAC;QAChC,MAAM;UACJC;QACF,CAAC,GAAGd,QAAQ;QACZ,MAAMe,MAAM,GAAGD,cAAc,CAACC,MAAM;QACpC,OAAO;UACLzH,IAAI,EAAE,CAACyH,MAAM,CAAC;UACdd,MAAM,EAAEa,cAAc,CAACE;QACzB,CAAC;MACH;IACF,KAAK,SAAS;MACZ;QACE,IAAIC,qBAAqB;QACzB,MAAMC,cAAc,GAAGlB,QAAQ,CAACnG,KAAK,GAAGmG,QAAQ,CAACzC,KAAK,CAAC,CAAC,GAAGtK,aAAa,CAAC+M,QAAQ,CAAC;QAClF,OAAO;UACL1G,IAAI,EAAE,CAAC4H,cAAc,CAACC,UAAU,CAAC5E,QAAQ,CAAC6E,KAAK,EAAE,CAACH,qBAAqB,GAAGC,cAAc,CAACrH,KAAK,MAAM,IAAI,IAAIoH,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAACG,KAAK,CAAC;UACpLnB,MAAM,EAAE,IAAIjP,OAAO,CAAC;QACtB,CAAC;MACH;IACF,KAAK,MAAM;MACT;QACE,MAAMqQ,CAAC,GAAGrB,QAAQ,CAACzC,KAAK,CAAC,CAAC;QAC1B,OAAO;UACLjE,IAAI,EAAE,CAAC+H,CAAC,CAACF,UAAU,CAAC5E,QAAQ,CAAC6E,KAAK,CAAC;UACnCnB,MAAM,EAAE,IAAIjP,OAAO,CAAC;QACtB,CAAC;MACH;EACJ;EACA,OAAO;IACLsI,IAAI,EAAE,EAAE;IACR2G,MAAM,EAAE,IAAIjP,OAAO,CAAC;EACtB,CAAC;AACH,CAAC;AACD,MAAMsQ,iCAAiC,GAAGjD,KAAK,IAAI;EACjD,OAAO;IACLkD,SAAS,EAAE,CAAC,EAAElD,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,IAAIA,KAAK,CAACmD,gBAAgB,IAAInD,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,IAAIA,KAAK,CAACoD,eAAe,IAAIpD,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,IAAIA,KAAK,CAACqD,mBAAmB,IAAIrD,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,IAAIA,KAAK,CAACsD,kBAAkB,CAAC;IAC/QC,YAAY,EAAE,CAAC,EAAEvD,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,IAAIA,KAAK,CAACwD,cAAc;EAC7E,CAAC;AACH,CAAC;AACD,MAAMC,iBAAiB,GAAGA,CAAC1D,WAAW,EAAEC,KAAK,EAAE0D,MAAM;AACrD;AACA;AACA;AACAC,YAAY,GAAG,CAAC,CAAC,KAAK;EACpB,MAAM;IACJR,gBAAgB;IAChBC,eAAe;IACfC,mBAAmB;IACnBC,kBAAkB;IAClBE;EACF,CAAC,GAAGxD,KAAK;EACTpM,SAAS,CAAC,MAAM;IACd,MAAMuI,QAAQ,GAAG4D,WAAW,CAAC,CAAC;IAC9B,IAAI5D,QAAQ,EAAE;MACZ,MAAM;QACJ+G,SAAS,EAAEU,qBAAqB;QAChCL,YAAY,EAAEM;MAChB,CAAC,GAAGZ,iCAAiC,CAACjD,KAAK,CAAC;MAC5C,MAAM8D,iBAAiB,GAAGF,qBAAqB,IAAID,YAAY,CAACT,SAAS;MACzE,MAAMa,oBAAoB,GAAGF,wBAAwB,IAAIF,YAAY,CAACJ,YAAY;MAClF,IAAIO,iBAAiB,IAAIC,oBAAoB,EAAE;QAC7C5H,QAAQ,CAAC6H,eAAe,CAACjR,YAAY,CAACkR,gBAAgB,GAAGlR,YAAY,CAACmR,oBAAoB,CAAC;MAC7F,CAAC,MAAM,IAAIJ,iBAAiB,EAAE;QAC5B3H,QAAQ,CAAC6H,eAAe,CAACjR,YAAY,CAACkR,gBAAgB,CAAC;MACzD,CAAC,MAAM,IAAIF,oBAAoB,EAAE;QAC/B5H,QAAQ,CAAC6H,eAAe,CAACjR,YAAY,CAACmR,oBAAoB,CAAC;MAC7D;MACAR,MAAM,CAAC/L,GAAG,CAACwE,QAAQ,CAACsC,MAAM,EAAE;QAC1B0E,gBAAgB;QAChBC,eAAe;QACfC,mBAAmB;QACnBC,kBAAkB;QAClBE;MACF,CAAC,CAAC;IACJ;IACA,OAAO,MAAM;MACX,IAAIrH,QAAQ,EAAE;QACZuH,MAAM,CAACS,MAAM,CAAChI,QAAQ,CAACsC,MAAM,CAAC;MAChC;IACF,CAAC;EACH,CAAC,EAAE,CAAC0E,gBAAgB,EAAEC,eAAe,EAAEC,mBAAmB,EAAEC,kBAAkB,EAAEE,cAAc,EAAEG,YAAY,CAAC,CAAC;AAChH,CAAC;AACD,MAAM5B,8BAA8B,GAAGA,CAAC/B,KAAK,GAAG,CAAC,CAAC,KAAK;EACrD,MAAMoE,IAAI,GAAGxJ,wBAAwB,CAACoF,KAAK,EAAElF,WAAW,CAAC;EACzD,OAAOsJ,IAAI;AACb,CAAC;;AAED;AACA,MAAMC,kBAAkB,GAAGC,EAAE,IAAI;EAC/B,MAAMrL,GAAG,GAAGtF,MAAM,CAAC2Q,EAAE,CAAC;EACtB1Q,SAAS,CAAC,MAAM;IACdqF,GAAG,CAACE,OAAO,GAAGmL,EAAE;EAClB,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC;EACR,OAAOrL,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMsL,SAAS,GAAGA,CAAA,KAAM;EACtB,MAAMC,MAAM,GAAGzQ,UAAU,CAAC0Q,aAAa,CAAC;EACxC,IAAI,CAACD,MAAM,EAAE,MAAM,IAAIjI,KAAK,CAAC,gEAAgE,CAAC;EAC9F,OAAOiI,MAAM;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAME,oBAAoB,GAAGrL,QAAQ,IAAI;EACvC,MAAM;IACJsL;EACF,CAAC,GAAGJ,SAAS,CAAC,CAAC;EACf,MAAMtL,GAAG,GAAGoL,kBAAkB,CAAChL,QAAQ,CAAC;EACxCzF,SAAS,CAAC,MAAM;IACd+Q,mBAAmB,CAACC,GAAG,CAAC3L,GAAG,CAAC;IAC5B,OAAO,MAAM;MACX0L,mBAAmB,CAACR,MAAM,CAAClL,GAAG,CAAC;IACjC,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAM4L,mBAAmB,GAAGxL,QAAQ,IAAI;EACtC,MAAM;IACJyL;EACF,CAAC,GAAGP,SAAS,CAAC,CAAC;EACf,MAAMtL,GAAG,GAAGoL,kBAAkB,CAAChL,QAAQ,CAAC;EACxCzF,SAAS,CAAC,MAAM;IACdkR,kBAAkB,CAACF,GAAG,CAAC3L,GAAG,CAAC;IAC3B,OAAO,MAAM;MACX6L,kBAAkB,CAACX,MAAM,CAAClL,GAAG,CAAC;IAChC,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAM8L,qBAAqB,GAAGA,CAAC9L,GAAG,EAAEyC,OAAO,EAAEwF,mBAAmB,GAAG,IAAI,KAAK;EAC1E,MAAM,CAACY,aAAa,EAAEkD,gBAAgB,CAAC,GAAGhR,QAAQ,CAAC,EAAE,CAAC;EACtDJ,SAAS,CAAC,MAAM;IACd,MAAMgL,MAAM,GAAG3F,GAAG,CAACE,OAAO;IAC1B,IAAIyF,MAAM,IAAIlD,OAAO,CAAC8F,SAAS,KAAK,KAAK,EAAE;MACzCwD,gBAAgB,CAAC/D,+BAA+B,CAAC;QAC/CrC,MAAM,EAAE3F,GAAG,CAACE,OAAO;QACnBuC,OAAO;QACPwF;MACF,CAAC,CAAC,CAAC;IACL;EACF,CAAC,EAAE,CAACxF,OAAO,CAAC8F,SAAS,CAAC,CAAC;EACvB,OAAOM,aAAa;AACtB,CAAC;AAED,MAAMmD,KAAK,GAAG,aAAapR,IAAI,CAAC,MAAM;EACpC,MAAM;IACJ8H;EACF,CAAC,GAAG4I,SAAS,CAAC,CAAC;EACf,MAAMtL,GAAG,GAAGtF,MAAM,CAAC,IAAI,CAAC;EACxBH,QAAQ,CAAC,MAAM;IACb,MAAM0R,IAAI,GAAGjM,GAAG,CAACE,OAAO;IACxB,IAAI,CAAC+L,IAAI,EAAE;IACX,MAAMC,OAAO,GAAGxJ,KAAK,CAACyJ,WAAW,CAAC,CAAC;IACnC,MAAMzD,QAAQ,GAAG,IAAIpN,cAAc,CAAC,CAAC;IACrCoN,QAAQ,CAAC0D,YAAY,CAAC,UAAU,EAAE,IAAI7Q,eAAe,CAAC2Q,OAAO,CAACzM,QAAQ,EAAE,CAAC,CAAC,CAAC;IAC3EiJ,QAAQ,CAAC0D,YAAY,CAAC,OAAO,EAAE,IAAI7Q,eAAe,CAAC2Q,OAAO,CAACG,MAAM,EAAE,CAAC,CAAC,CAAC;IACtEJ,IAAI,CAACvD,QAAQ,CAAC4D,OAAO,CAAC,CAAC;IACvBL,IAAI,CAACvD,QAAQ,GAAGA,QAAQ;EAC1B,CAAC,CAAC;EACF,OAAO,aAAajO,KAAK,CAAC4G,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,aAAa5G,KAAK,CAAC4G,aAAa,CAAC,cAAc,EAAE;IACtGrB,GAAG,EAAEA,GAAG;IACRuM,aAAa,EAAE;EACjB,CAAC,EAAE,aAAa9R,KAAK,CAAC4G,aAAa,CAAC,mBAAmB,EAAE;IACvDmL,KAAK,EAAE,QAAQ;IACfC,YAAY,EAAE;EAChB,CAAC,CAAC,EAAE,aAAahS,KAAK,CAAC4G,aAAa,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC,CAAC;AAChE,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,MAAMqL,oBAAoB,GAAGC,cAAc,IAAI;EAC7C,IAAIC,QAAQ;EACZ,MAAMC,OAAO,GAAG;IACdtH,GAAGA,CAACuH,MAAM,EAAEC,IAAI,EAAE;MAChB,IAAI,CAACH,QAAQ,EAAE;QACbA,QAAQ,GAAGD,cAAc,CAAC,CAAC;MAC7B;MACA,OAAOK,OAAO,CAACzH,GAAG,CAACqH,QAAQ,EAAEG,IAAI,CAAC;IACpC,CAAC;IACDrO,GAAGA,CAACoO,MAAM,EAAEC,IAAI,EAAEpQ,KAAK,EAAE;MACvB,IAAI,CAACiQ,QAAQ,EAAE;QACbA,QAAQ,GAAGD,cAAc,CAAC,CAAC;MAC7B;MACA,OAAOK,OAAO,CAACtO,GAAG,CAACkO,QAAQ,EAAEG,IAAI,EAAEpQ,KAAK,CAAC;IAC3C;EACF,CAAC;EACD,MAAMsQ,KAAK,GAAG,IAAIC,KAAK,CAAC,CAAC,CAAC,EAAEL,OAAO,CAAC;EACpC,MAAMM,KAAK,GAAGA,CAAA,KAAM;IAClBP,QAAQ,GAAG3M,SAAS;EACtB,CAAC;EACD,MAAMvB,GAAG,GAAG0O,WAAW,IAAI;IACzBR,QAAQ,GAAGQ,WAAW;EACxB,CAAC;;EAED;AACF;AACA;EACE,OAAO;IACLH,KAAK;IACLE,KAAK;IACLzO;EACF,CAAC;AACH,CAAC;AAED,MAAM8M,aAAa,GAAG,aAAaxQ,aAAa,CAACiF,SAAS,CAAC;AAC3D,MAAMoN,6BAA6B,GAAGA,CAACP,MAAM,EAAEQ,KAAK,KAAK;EACvD,IAAIC,qBAAqB,EAAEC,qBAAqB,EAAEC,qBAAqB,EAAEC,qBAAqB,EAAEC,sBAAsB,EAAEC,sBAAsB;EAC9I,OAAO;IACLd,MAAM,EAAE;MACNe,SAAS,EAAEf,MAAM,CAACe,SAAS,CAAClI,MAAM;MAClCzC,QAAQ,EAAE4J,MAAM,CAAC5J,QAAQ,CAACyC,MAAM;MAChCmI,cAAc,EAAE,CAACP,qBAAqB,GAAGT,MAAM,CAAC5J,QAAQ,CAACoC,KAAK,MAAM,IAAI,IAAIiI,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAAC5H,MAAM;MACpJ+B,eAAe,EAAE,CAAC8F,qBAAqB,GAAGV,MAAM,CAACe,SAAS,CAACvI,KAAK,MAAM,IAAI,IAAIkI,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAAC7H;IAClJ,CAAC;IACD2H,KAAK,EAAE;MACLO,SAAS,EAAEP,KAAK,CAACO,SAAS,CAAClI,MAAM;MACjCzC,QAAQ,EAAEoK,KAAK,CAACpK,QAAQ,CAACyC,MAAM;MAC/BmI,cAAc,EAAE,CAACL,qBAAqB,GAAGH,KAAK,CAACpK,QAAQ,CAACoC,KAAK,MAAM,IAAI,IAAImI,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAAC9H,MAAM;MACnJ+B,eAAe,EAAE,CAACgG,qBAAqB,GAAGJ,KAAK,CAACO,SAAS,CAACvI,KAAK,MAAM,IAAI,IAAIoI,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAAC/H;IACjJ,CAAC;IACDkI,SAAS,EAAEP,KAAK,CAACO,SAAS,CAAClI,MAAM;IACjCzC,QAAQ,EAAEoK,KAAK,CAACpK,QAAQ,CAACyC,MAAM;IAC/BmI,cAAc,EAAE,CAACH,sBAAsB,GAAGL,KAAK,CAACpK,QAAQ,CAACoC,KAAK,MAAM,IAAI,IAAIqI,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAChI,MAAM;IACtJ+B,eAAe,EAAE,CAACkG,sBAAsB,GAAGN,KAAK,CAACO,SAAS,CAACvI,KAAK,MAAM,IAAI,IAAIsI,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACjI;EACpJ,CAAC;AACH,CAAC;AACD,MAAMoI,YAAY,GAAG,MAAAA,CAAA,KAAY;EAC/B,IAAIjS,CAAC,GAAG,MAAM,MAAM,CAAC,2BAA2B,CAAC;EACjD,MAAMA,CAAC,CAACkS,IAAI,CAAC,CAAC;EACd,OAAOlS,CAAC;AACV,CAAC;AACD;AACA;AACA;AACA;AACA,MAAMmS,OAAO,GAAGlH,KAAK,IAAI;EACvB,MAAM;IACJwB,SAAS,GAAG,QAAQ;IACpB2F,QAAQ;IACRC,QAAQ,GAAG,CAAC,GAAG,EAAE;IACjBC,MAAM,GAAG,KAAK;IACdC,WAAW,GAAG,IAAI;IAClBrN,cAAc;IACdsN,UAAU,GAAG,QAAQ;IACrBC,KAAK,GAAG,KAAK;IACbC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;IACvBC,kBAAkB,GAAG,KAAK;IAC1BC,kBAAkB,GAAG,KAAK;IAC1BC,mBAAmB,GAAG,CAAC;IACvBC,+BAA+B,GAAG,CAAC;IACnCC,wBAAwB,GAAG,CAAC;IAC5BC,aAAa,GAAG,GAAG;IACnBC,cAAc,GAAG,CAAC;IAClBC,uBAAuB,GAAG,EAAE;IAC5BC,UAAU,GAAG;EACf,CAAC,GAAGlI,KAAK;EACT,MAAMwE,MAAM,GAAG7P,OAAO,CAACqS,YAAY,EAAE,CAAC,oBAAoB,EAAEA,YAAY,CAAC,CAAC;EAC1E,MAAM;IACJmB;EACF,CAAC,GAAG1U,QAAQ,CAAC,CAAC;EACd,MAAM2U,eAAe,GAAGrP,QAAQ,CAAC,MAAM,IAAIsP,GAAG,CAAC,CAAC,CAAC;EACjD,MAAMC,cAAc,GAAGvP,QAAQ,CAAC,MAAM,IAAIsP,GAAG,CAAC,CAAC,CAAC;EAChD,MAAME,eAAe,GAAGxP,QAAQ,CAAC,MAAM,IAAIsP,GAAG,CAAC,CAAC,CAAC;EACjD,MAAMG,cAAc,GAAGzP,QAAQ,CAAC,MAAM,IAAIsP,GAAG,CAAC,CAAC,CAAC;EAChD,MAAMI,UAAU,GAAG1P,QAAQ,CAAC,MAAM,IAAI9F,UAAU,CAAC,KAAK,CAAC,CAAC;EACxD,MAAM0R,mBAAmB,GAAG5L,QAAQ,CAAC,MAAM,IAAI2P,GAAG,CAAC,CAAC,CAAC;EACrD,MAAM5D,kBAAkB,GAAG/L,QAAQ,CAAC,MAAM,IAAI2P,GAAG,CAAC,CAAC,CAAC;;EAEpD;AACF;AACA;AACA;AACA;EACE,MAAM;IACJxC,KAAK,EAAEyC,UAAU;IACjBvC,KAAK,EAAEwC,eAAe;IACtBjR,GAAG,EAAEkR;EACP,CAAC,GAAG9P,QAAQ,CAAC,MAAM4M,oBAAoB,CAAC,MAAM,IAAInB,MAAM,CAACsE,KAAK,CAAC1R,oBAAoB,CAACqQ,OAAO,CAAC,CAAC,CAAC,CAAC;EAC/F7T,SAAS,CAAC,MAAM;IACd,OAAO,MAAM;MACX+U,UAAU,CAACI,IAAI,CAAC,CAAC;MACjBH,eAAe,CAAC,CAAC;IACnB,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;;EAEN;EACAhV,SAAS,CAAC,MAAM;IACd+U,UAAU,CAAClB,OAAO,GAAG7P,qBAAqB,CAAC6P,OAAO,CAAC;IACnDkB,UAAU,CAACK,qBAAqB,CAACpB,mBAAmB,GAAGA,mBAAmB;IAC1Ee,UAAU,CAACK,qBAAqB,CAACnB,+BAA+B,GAAGA,+BAA+B;IAClGc,UAAU,CAACK,qBAAqB,CAAClB,wBAAwB,GAAGA,wBAAwB;IACpFa,UAAU,CAACK,qBAAqB,CAACC,4BAA4B,GAAGvB,kBAAkB;IAClFiB,UAAU,CAACK,qBAAqB,CAACjB,aAAa,GAAGA,aAAa;IAC9DY,UAAU,CAACK,qBAAqB,CAAChB,cAAc,GAAGA,cAAc;IAChEW,UAAU,CAACK,qBAAqB,CAACE,4BAA4B,GAAGvB,kBAAkB;IAClFgB,UAAU,CAACT,UAAU,GAAGA,UAAU;IAClCS,UAAU,CAACK,qBAAqB,CAACG,yBAAyB,GAAGlB,uBAAuB;EACtF,CAAC,EAAE,CAACU,UAAU,EAAE,GAAGlB,OAAO,EAAEG,mBAAmB,EAAEC,+BAA+B,EAAEC,wBAAwB,EAAEJ,kBAAkB,EAAEK,aAAa,EAAEC,cAAc,EAAEL,kBAAkB,EAAEO,UAAU,EAAED,uBAAuB,CAAC,CAAC;EACxN,MAAMmB,2BAA2B,GAAGlV,WAAW,CAACuK,MAAM,IAAI;IACxD,IAAI4K,gBAAgB;IACpB,MAAMlN,QAAQ,GAAGwM,UAAU,CAAC5I,WAAW,CAACtB,MAAM,CAAC;IAC/C,MAAM6K,SAAS,GAAGd,cAAc,CAAChK,GAAG,CAACC,MAAM,CAAC;IAC5C,MAAM8K,aAAa,GAAGjB,cAAc,CAAC9J,GAAG,CAACC,MAAM,CAAC;IAChD,MAAM+K,eAAe,GAAGrN,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACkN,gBAAgB,GAAGlN,QAAQ,CAAC0C,MAAM,CAAC,CAAC,MAAM,IAAI,IAAIwK,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAAC5K,MAAM;IAC7L,MAAMqI,SAAS,GAAG0C,eAAe,KAAKtQ,SAAS,GAAGyP,UAAU,CAAC/M,YAAY,CAAC4N,eAAe,CAAC,GAAGtQ,SAAS;IACtG,MAAMuQ,QAAQ,GAAG3C,SAAS,IAAI0C,eAAe,KAAKtQ,SAAS,GAAGqP,eAAe,CAAC/J,GAAG,CAACgL,eAAe,CAAC,GAAGtQ,SAAS;IAC9G,MAAMwQ,cAAc,GAAGF,eAAe,KAAKtQ,SAAS,GAAGkP,eAAe,CAAC5J,GAAG,CAACgL,eAAe,CAAC,GAAGtQ,SAAS;IACvG,MAAMyQ,MAAM,GAAG;MACbxN,QAAQ,EAAE;QACRyC,MAAM,EAAEzC,QAAQ;QAChBuH,MAAM,EAAE4F,SAAS;QACjB/K,KAAK,EAAEgL;MACT,CAAC;MACDzC,SAAS,EAAE;QACTlI,MAAM,EAAEkI,SAAS;QACjBpD,MAAM,EAAE+F,QAAQ;QAChBlL,KAAK,EAAEmL;MACT;IACF,CAAC;IACD,OAAOC,MAAM;EACf,CAAC,EAAE,EAAE,CAAC;EACN,MAAM,CAACC,aAAa,CAAC,GAAG5V,QAAQ,CAAC;IAC/B6V,aAAa,EAAE,CAAC,CAAC;IACjBC,WAAW,EAAE;EACf,CAAC,CAAC;EACF,MAAMC,IAAI,GAAG7V,WAAW,CAACiG,EAAE,IAAI;IAC7B,MAAMwB,KAAK,GAAGgN,UAAU;;IAExB;AACJ;IACI,MAAMqB,gBAAgB,GAAG5C,QAAQ,KAAK,MAAM;;IAE5C;AACJ;AACA;AACA;;IAEI,MAAM6C,YAAY,GAAGxV,SAAS,CAACyV,KAAK,CAAC/P,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC;IAChD,MAAMgQ,SAAS,GAAGvQ,KAAK,IAAI;MACzB;MACA+K,mBAAmB,CAAChO,OAAO,CAAC0C,QAAQ,IAAI;QACtCA,QAAQ,CAACF,OAAO,CAACwC,KAAK,CAAC;MACzB,CAAC,CAAC;MACFA,KAAK,CAACyO,QAAQ,GAAGxQ,KAAK;MACtB+B,KAAK,CAACoO,IAAI,CAACtB,UAAU,CAAC;;MAEtB;MACA3D,kBAAkB,CAACnO,OAAO,CAAC0C,QAAQ,IAAI;QACrCA,QAAQ,CAACF,OAAO,CAACwC,KAAK,CAAC;MACzB,CAAC,CAAC;IACJ,CAAC;IACD,IAAIqO,gBAAgB,EAAE;MACpBG,SAAS,CAACF,YAAY,CAAC;IACzB,CAAC,MAAM;MACL;MACA;MACAL,aAAa,CAACE,WAAW,IAAIG,YAAY;MACzC,OAAOL,aAAa,CAACE,WAAW,IAAI1C,QAAQ,EAAE;QAC5C;QACA;QACA,IAAIE,WAAW,EAAE;UACfsC,aAAa,CAACC,aAAa,GAAG,CAAC,CAAC;UAChClO,KAAK,CAAC0O,gBAAgB,CAACC,IAAI,IAAI;YAC7BV,aAAa,CAACC,aAAa,CAACS,IAAI,CAAC7L,MAAM,CAAC,GAAG;cACzCP,QAAQ,EAAEoM,IAAI,CAACC,WAAW,CAAC,CAAC;cAC5BpM,QAAQ,EAAEmM,IAAI,CAACnM,QAAQ,CAAC;YAC1B,CAAC;UACH,CAAC,CAAC;QACJ;QACAgM,SAAS,CAAC/C,QAAQ,CAAC;QACnBwC,aAAa,CAACE,WAAW,IAAI1C,QAAQ;MACvC;IACF;IACA,MAAMoD,kBAAkB,GAAGR,gBAAgB,IAAI,CAAC1C,WAAW,IAAID,MAAM,GAAG,CAAC,GAAGuC,aAAa,CAACE,WAAW,GAAG1C,QAAQ;;IAEhH;IACAgB,eAAe,CAACzR,OAAO,CAAC,CAAC4H,KAAK,EAAEE,MAAM,KAAK;MACzC,MAAMqI,SAAS,GAAGnL,KAAK,CAACC,YAAY,CAAC6C,MAAM,CAAC;MAC5C,MAAMiF,MAAM,GAAG6E,eAAe,CAAC/J,GAAG,CAACC,MAAM,CAAC;MAC1C,IAAIiF,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,IAAIA,MAAM,CAAC+G,OAAO,IAAI/G,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,IAAIA,MAAM,CAACgH,MAAM,EAAE;QACnH,IAAI5D,SAAS,CAAC6D,UAAU,CAAC,CAAC,IAAI,CAACpM,KAAK,CAACoM,UAAU,EAAE;UAC/C,IAAIC,eAAe;UACnBlH,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACkH,eAAe,GAAGlH,MAAM,CAAC+G,OAAO,MAAM,IAAI,IAAIG,eAAe,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,eAAe,CAACxV,IAAI,CAACsO,MAAM,CAAC;QACnK;QACA,IAAI,CAACoD,SAAS,CAAC6D,UAAU,CAAC,CAAC,IAAIpM,KAAK,CAACoM,UAAU,EAAE;UAC/C,IAAIE,cAAc;UAClBnH,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACmH,cAAc,GAAGnH,MAAM,CAACgH,MAAM,MAAM,IAAI,IAAIG,cAAc,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,cAAc,CAACzV,IAAI,CAACsO,MAAM,CAAC;QAC/J;QACAnF,KAAK,CAACoM,UAAU,GAAG7D,SAAS,CAAC6D,UAAU,CAAC,CAAC;MAC3C;MACA,IAAI,CAAC7D,SAAS,IAAIA,SAAS,CAAC6D,UAAU,CAAC,CAAC,IAAI,EAAE,iBAAiB,IAAIpM,KAAK,CAACK,MAAM,CAAC,IAAI,CAACL,KAAK,CAACuM,SAAS,EAAE;QACpG;MACF;;MAEA;MACA,IAAIhW,CAAC,GAAGgS,SAAS,CAACyD,WAAW,CAAC,CAAC;MAC/B,IAAIxV,CAAC,GAAG+R,SAAS,CAAC3I,QAAQ,CAAC,CAAC;MAC5B,IAAI0L,aAAa,GAAGD,aAAa,CAACC,aAAa,CAACpL,MAAM,CAAC;MACvD,IAAIoL,aAAa,EAAE;QACjB;QACA7S,QAAQ,CAAC+T,OAAO,CAAClB,aAAa,CAAC3L,QAAQ,EAAEzG,4BAA4B,CAACoS,aAAa,CAAC1L,QAAQ,CAAC,EAAEI,KAAK,CAAC5F,KAAK,CAAC,CAAC2G,WAAW,CAACf,KAAK,CAACyM,mBAAmB,CAAC,CAACzL,SAAS,CAACtI,SAAS,EAAEC,SAAS,EAAEC,MAAM,CAAC;;QAE1L;QACA,IAAIoH,KAAK,CAAC0M,QAAQ,IAAI,MAAM,EAAE;UAC5B1M,KAAK,CAACK,MAAM,CAACV,QAAQ,CAACmB,IAAI,CAACpI,SAAS,CAAC;UACrCsH,KAAK,CAACK,MAAM,CAACX,UAAU,CAACoB,IAAI,CAACnI,SAAS,CAAC;QACzC;MACF;;MAEA;MACAF,QAAQ,CAAC+T,OAAO,CAACjW,CAAC,EAAE2C,4BAA4B,CAAC1C,CAAC,CAAC,EAAEwJ,KAAK,CAAC5F,KAAK,CAAC,CAAC2G,WAAW,CAACf,KAAK,CAACyM,mBAAmB,CAAC,CAACzL,SAAS,CAACtI,SAAS,EAAEC,SAAS,EAAEC,MAAM,CAAC;MAChJ,IAAIoH,KAAK,CAAC0M,QAAQ,IAAI,eAAe,EAAE;QACrC1M,KAAK,CAACuM,SAAS,CAAC9T,QAAQ,CAAC;MAC3B,CAAC,MAAM;QACL;QACAuH,KAAK,CAACK,MAAM,CAACV,QAAQ,CAACgN,IAAI,CAACjU,SAAS,EAAEuT,kBAAkB,CAAC;QACzDjM,KAAK,CAACK,MAAM,CAACX,UAAU,CAACkN,KAAK,CAACjU,SAAS,EAAEsT,kBAAkB,CAAC;MAC9D;IACF,CAAC,CAAC;IACF/B,UAAU,CAAC2C,oBAAoB,CAAC,CAACC,OAAO,EAAEC,OAAO,EAAEC,OAAO,KAAK;MAC7D,MAAMC,OAAO,GAAGpC,2BAA2B,CAACiC,OAAO,CAAC;MACpD,MAAMI,OAAO,GAAGrC,2BAA2B,CAACkC,OAAO,CAAC;;MAEpD;MACA,IAAI,EAAEE,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,IAAIA,OAAO,CAACrP,QAAQ,CAACyC,MAAM,CAAC,IAAI,EAAE6M,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,IAAIA,OAAO,CAACtP,QAAQ,CAACyC,MAAM,CAAC,EAAE;QAChJ;MACF;MACA,MAAM8M,iBAAiB,GAAGpF,6BAA6B,CAACkF,OAAO,EAAEC,OAAO,CAAC;MACzE,MAAME,iBAAiB,GAAGrF,6BAA6B,CAACmF,OAAO,EAAED,OAAO,CAAC;MACzE,IAAID,OAAO,EAAE;QACX5P,KAAK,CAACiQ,WAAW,CAACJ,OAAO,CAACrP,QAAQ,CAACyC,MAAM,EAAE6M,OAAO,CAACtP,QAAQ,CAACyC,MAAM,EAAE,CAACiN,QAAQ,EAAEC,OAAO,KAAK;UACzF,IAAIC,qBAAqB,EAAEC,sBAAsB,EAAEC,qBAAqB,EAAEC,sBAAsB,EAAEC,qBAAqB,EAAEC,sBAAsB,EAAEC,qBAAqB,EAAEC,sBAAsB;UAC9L;UACA,CAACP,qBAAqB,GAAGP,OAAO,CAAC1E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAIqI,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,qBAAqB,CAAC5I,gBAAgB,MAAM,IAAI,IAAI6I,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAC5W,IAAI,CAAC2W,qBAAqB,EAAEvV,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEkV,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE;YACjVG,QAAQ;YACRC;UACF,CAAC,CAAC,CAAC;UACH,CAACG,qBAAqB,GAAGR,OAAO,CAAC3E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAIuI,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,qBAAqB,CAAC9I,gBAAgB,MAAM,IAAI,IAAI+I,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAC9W,IAAI,CAAC6W,qBAAqB,EAAEzV,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEmV,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE;YACjVE,QAAQ;YACRC;UACF,CAAC,CAAC,CAAC;;UAEH;UACA,CAACK,qBAAqB,GAAGX,OAAO,CAACrP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAIyI,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,qBAAqB,CAAChJ,gBAAgB,MAAM,IAAI,IAAIiJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAChX,IAAI,CAAC+W,qBAAqB,EAAE3V,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEkV,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE;YAChVG,QAAQ;YACRC;UACF,CAAC,CAAC,CAAC;UACH,CAACO,qBAAqB,GAAGZ,OAAO,CAACtP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAI2I,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,qBAAqB,CAAClJ,gBAAgB,MAAM,IAAI,IAAImJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAClX,IAAI,CAACiX,qBAAqB,EAAE7V,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEmV,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE;YAChVE,QAAQ;YACRC;UACF,CAAC,CAAC,CAAC;QACL,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,IAAIS,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB;QAClM,CAACP,sBAAsB,GAAGf,OAAO,CAAC1E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAI6I,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAACnJ,eAAe,MAAM,IAAI,IAAIoJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACpX,IAAI,CAACmX,sBAAsB,EAAEb,iBAAiB,CAAC;QAC9S,CAACe,sBAAsB,GAAGhB,OAAO,CAAC3E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAI+I,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAACrJ,eAAe,MAAM,IAAI,IAAIsJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACtX,IAAI,CAACqX,sBAAsB,EAAEd,iBAAiB,CAAC;QAC9S,CAACgB,sBAAsB,GAAGnB,OAAO,CAACrP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAIiJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAACvJ,eAAe,MAAM,IAAI,IAAIwJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACxX,IAAI,CAACuX,sBAAsB,EAAEjB,iBAAiB,CAAC;QAC7S,CAACmB,sBAAsB,GAAGpB,OAAO,CAACtP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAImJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAACzJ,eAAe,MAAM,IAAI,IAAI0J,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAC1X,IAAI,CAACyX,sBAAsB,EAAElB,iBAAiB,CAAC;MAC/S;;MAEA;MACA,IAAIJ,OAAO,EAAE;QACX,IAAI5P,KAAK,CAACoR,gBAAgB,CAACvB,OAAO,CAACrP,QAAQ,CAACyC,MAAM,EAAE6M,OAAO,CAACtP,QAAQ,CAACyC,MAAM,CAAC,EAAE;UAC5E,IAAIoO,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB;UAClM,CAACP,sBAAsB,GAAGxB,OAAO,CAAC1E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAIsJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAAC3J,mBAAmB,MAAM,IAAI,IAAI4J,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAC7X,IAAI,CAAC4X,sBAAsB,EAAEtB,iBAAiB,CAAC;UAClT,CAACwB,sBAAsB,GAAGzB,OAAO,CAAC3E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAIwJ,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAAC7J,mBAAmB,MAAM,IAAI,IAAI8J,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAC/X,IAAI,CAAC8X,sBAAsB,EAAEvB,iBAAiB,CAAC;UAClT,CAACyB,sBAAsB,GAAG5B,OAAO,CAACrP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAI0J,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAAC/J,mBAAmB,MAAM,IAAI,IAAIgK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACjY,IAAI,CAACgY,sBAAsB,EAAE1B,iBAAiB,CAAC;UACjT,CAAC4B,sBAAsB,GAAG7B,OAAO,CAACtP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAI4J,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAACjK,mBAAmB,MAAM,IAAI,IAAIkK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACnY,IAAI,CAACkY,sBAAsB,EAAE3B,iBAAiB,CAAC;QACnT;MACF,CAAC,MAAM;QACL,IAAI6B,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB,EAAEC,sBAAsB;QAClM,CAACP,sBAAsB,GAAGhC,OAAO,CAAC1E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAI8J,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAAClK,kBAAkB,MAAM,IAAI,IAAImK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACrY,IAAI,CAACoY,sBAAsB,EAAE9B,iBAAiB,CAAC;QACjT,CAACgC,sBAAsB,GAAGjC,OAAO,CAAC3E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAIgK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAACpK,kBAAkB,MAAM,IAAI,IAAIqK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACvY,IAAI,CAACsY,sBAAsB,EAAE/B,iBAAiB,CAAC;QACjT,CAACiC,sBAAsB,GAAGpC,OAAO,CAACrP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAIkK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAACtK,kBAAkB,MAAM,IAAI,IAAIuK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACzY,IAAI,CAACwY,sBAAsB,EAAElC,iBAAiB,CAAC;QAChT,CAACoC,sBAAsB,GAAGrC,OAAO,CAACtP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAIoK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,sBAAsB,GAAGD,sBAAsB,CAACxK,kBAAkB,MAAM,IAAI,IAAIyK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAAC3Y,IAAI,CAAC0Y,sBAAsB,EAAEnC,iBAAiB,CAAC;MAClT;IACF,CAAC,CAAC;IACFlD,UAAU,CAACuF,uBAAuB,CAACC,KAAK,IAAI;MAC1C,IAAIC,sBAAsB,EAAEC,uBAAuB,EAAEC,sBAAsB,EAAEC,uBAAuB,EAAEC,sBAAsB,EAAEC,uBAAuB,EAAEC,sBAAsB,EAAEC,uBAAuB;MACtM,MAAMjD,OAAO,GAAGpC,2BAA2B,CAAC6E,KAAK,CAACS,SAAS,CAAC,CAAC,CAAC;MAC9D,MAAMjD,OAAO,GAAGrC,2BAA2B,CAAC6E,KAAK,CAACU,SAAS,CAAC,CAAC,CAAC;;MAE9D;MACA,IAAI,EAAEnD,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,IAAIA,OAAO,CAACrP,QAAQ,CAACyC,MAAM,CAAC,IAAI,EAAE6M,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,IAAIA,OAAO,CAACtP,QAAQ,CAACyC,MAAM,CAAC,EAAE;QAChJ;MACF;MACA,MAAM8M,iBAAiB,GAAGpF,6BAA6B,CAACkF,OAAO,EAAEC,OAAO,CAAC;MACzE,MAAME,iBAAiB,GAAGrF,6BAA6B,CAACmF,OAAO,EAAED,OAAO,CAAC;MACzE,CAAC0C,sBAAsB,GAAG1C,OAAO,CAAC1E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAIwK,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,uBAAuB,GAAGD,sBAAsB,CAAC1K,cAAc,MAAM,IAAI,IAAI2K,uBAAuB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,uBAAuB,CAAC/Y,IAAI,CAAC8Y,sBAAsB,EAAE1X,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEkV,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE;QACtVkD,UAAU,EAAEX,KAAK,CAACW,UAAU,CAAC,CAAC;QAC9BC,mBAAmB,EAAEZ,KAAK,CAACY,mBAAmB,CAAC,CAAC;QAChDC,iBAAiB,EAAEb,KAAK,CAACa,iBAAiB,CAAC,CAAC;QAC5CC,iBAAiB,EAAEd,KAAK,CAACc,iBAAiB,CAAC;MAC7C,CAAC,CAAC,CAAC;MACH,CAACX,sBAAsB,GAAG3C,OAAO,CAAC3E,SAAS,CAACpD,MAAM,MAAM,IAAI,IAAI0K,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,uBAAuB,GAAGD,sBAAsB,CAAC5K,cAAc,MAAM,IAAI,IAAI6K,uBAAuB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,uBAAuB,CAACjZ,IAAI,CAACgZ,sBAAsB,EAAE5X,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEmV,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE;QACtViD,UAAU,EAAEX,KAAK,CAACW,UAAU,CAAC,CAAC;QAC9BC,mBAAmB,EAAEZ,KAAK,CAACY,mBAAmB,CAAC,CAAC;QAChDC,iBAAiB,EAAEb,KAAK,CAACa,iBAAiB,CAAC,CAAC;QAC5CC,iBAAiB,EAAEd,KAAK,CAACc,iBAAiB,CAAC;MAC7C,CAAC,CAAC,CAAC;MACH,CAACT,sBAAsB,GAAG9C,OAAO,CAACrP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAI4K,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,uBAAuB,GAAGD,sBAAsB,CAAC9K,cAAc,MAAM,IAAI,IAAI+K,uBAAuB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,uBAAuB,CAACnZ,IAAI,CAACkZ,sBAAsB,EAAE9X,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEkV,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE;QACrVkD,UAAU,EAAEX,KAAK,CAACW,UAAU,CAAC,CAAC;QAC9BC,mBAAmB,EAAEZ,KAAK,CAACY,mBAAmB,CAAC,CAAC;QAChDC,iBAAiB,EAAEb,KAAK,CAACa,iBAAiB,CAAC,CAAC;QAC5CC,iBAAiB,EAAEd,KAAK,CAACc,iBAAiB,CAAC;MAC7C,CAAC,CAAC,CAAC;MACH,CAACP,sBAAsB,GAAG/C,OAAO,CAACtP,QAAQ,CAACuH,MAAM,MAAM,IAAI,IAAI8K,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAACC,uBAAuB,GAAGD,sBAAsB,CAAChL,cAAc,MAAM,IAAI,IAAIiL,uBAAuB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,uBAAuB,CAACrZ,IAAI,CAACoZ,sBAAsB,EAAEhY,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEmV,iBAAiB,CAAC,EAAE,CAAC,CAAC,EAAE;QACrViD,UAAU,EAAEX,KAAK,CAACW,UAAU,CAAC,CAAC;QAC9BC,mBAAmB,EAAEZ,KAAK,CAACY,mBAAmB,CAAC,CAAC;QAChDC,iBAAiB,EAAEb,KAAK,CAACa,iBAAiB,CAAC,CAAC;QAC5CC,iBAAiB,EAAEd,KAAK,CAACc,iBAAiB,CAAC;MAC7C,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IACFpT,KAAK,CAACqT,sBAAsB,CAAC,MAAM;MACjC7G,UAAU,CAAC,CAAC;IACd,CAAC,CAAC;EACJ,CAAC,EAAE,CAACd,MAAM,EAAED,QAAQ,EAAEE,WAAW,EAAEqB,UAAU,CAAC,CAAC;EAC/C,MAAMsG,OAAO,GAAGnb,OAAO,CAAC,OAAO;IAC7B0Q,MAAM;IACN7I,KAAK,EAAEgN,UAAU;IACjBuG,QAAQ,EAAEvT,KAAK,IAAI;MACjBkN,aAAa,CAAClN,KAAK,CAAC;IACtB,CAAC;IACDwT,cAAc,EAAE;MACd3N,SAAS;MACTiG;IACF,CAAC;IACDW,eAAe;IACfE,cAAc;IACdC,eAAe;IACfC,cAAc;IACd7D,mBAAmB;IACnBG,kBAAkB;IAClBsK,QAAQ,EAAE/H,MAAM;IAChBgI,OAAO,EAAE7H,KAAK;IACduC;EACF,CAAC,CAAC,EAAE,CAAC1C,MAAM,EAAE0C,IAAI,EAAEvC,KAAK,EAAEhG,SAAS,EAAEiG,OAAO,CAAC,CAAC;EAC9C,MAAM6H,YAAY,GAAGpb,WAAW,CAAC0F,KAAK,IAAI;IACxC,IAAI,CAACyN,MAAM,EAAE;MACX0C,IAAI,CAACnQ,KAAK,CAAC;IACb;EACF,CAAC,EAAE,CAACyN,MAAM,EAAE0C,IAAI,CAAC,CAAC;EAClB,OAAO,aAAarW,KAAK,CAAC4G,aAAa,CAACmK,aAAa,CAAC8K,QAAQ,EAAE;IAC9D3Z,KAAK,EAAEqZ;EACT,CAAC,EAAE,aAAavb,KAAK,CAAC4G,aAAa,CAACC,cAAc,EAAE;IAClDP,MAAM,EAAEsV,YAAY;IACpB9W,IAAI,EAAE+O,UAAU;IAChBtN,cAAc,EAAEA;EAClB,CAAC,CAAC,EAAEuN,KAAK,IAAI,aAAa9T,KAAK,CAAC4G,aAAa,CAAC2K,KAAK,EAAE,IAAI,CAAC,EAAEkC,QAAQ,CAAC;AACvE,CAAC;AAED,SAASqI,QAAQA,CAAA,EAAG;EAClB,OAAOA,QAAQ,GAAG9Z,MAAM,CAAC+Z,MAAM,GAAG/Z,MAAM,CAAC+Z,MAAM,CAACC,IAAI,CAAC,CAAC,GAAG,UAAUjV,CAAC,EAAE;IACpE,KAAK,IAAIzF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyB,SAAS,CAACC,MAAM,EAAE1B,CAAC,EAAE,EAAE;MACzC,IAAIF,CAAC,GAAG2B,SAAS,CAACzB,CAAC,CAAC;MACpB,KAAK,IAAID,CAAC,IAAID,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE4F,cAAc,CAACtF,IAAI,CAACN,CAAC,EAAEC,CAAC,CAAC,KAAK0F,CAAC,CAAC1F,CAAC,CAAC,GAAGD,CAAC,CAACC,CAAC,CAAC,CAAC;IAClE;IACA,OAAO0F,CAAC;EACV,CAAC,EAAE+U,QAAQ,CAACjZ,KAAK,CAAC,IAAI,EAAEE,SAAS,CAAC;AACpC;;AAEA;AACA,MAAMkZ,eAAe,GAAGA,CAACC,YAAY,EAAEC,YAAY,GAAG,IAAI,KAAK;EAC7D,MAAMC,QAAQ,GAAGnc,MAAM,CAACkc,YAAY,CAAC;;EAErC;EACA,IAAID,YAAY,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;IACtD,IAAI,CAACA,YAAY,CAACzW,OAAO,EAAE;MACzByW,YAAY,CAACzW,OAAO,GAAG2W,QAAQ,CAAC3W,OAAO;IACzC;IACA,OAAOyW,YAAY;EACrB;EACA,OAAOE,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA,MAAMC,qBAAqB,GAAGA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,cAAc,KAAK;EACrE,MAAMjX,GAAG,GAAGtF,MAAM,CAACuF,SAAS,CAAC;EAC7B,MAAMiX,WAAW,GAAGjc,WAAW,CAAC,MAAM;IACpC,IAAI,CAAC+E,GAAG,CAACE,OAAO,EAAE;MAChBF,GAAG,CAACE,OAAO,GAAG6W,QAAQ,CAAC,CAAC;IAC1B;IACA,OAAO/W,GAAG,CAACE,OAAO;EACpB,CAAC,EAAE+W,cAAc,CAAC;EAClBtc,SAAS,CAAC,MAAM;IACd;IACA,MAAMiS,QAAQ,GAAGsK,WAAW,CAAC,CAAC;IAC9B,MAAMC,OAAO,GAAGA,CAAA,KAAMH,SAAS,CAACpK,QAAQ,CAAC;IACzC,OAAO,MAAM;MACXuK,OAAO,CAAC,CAAC;MACTnX,GAAG,CAACE,OAAO,GAAGD,SAAS;IACzB,CAAC;EACH,CAAC,EAAE,CAACiX,WAAW,CAAC,CAAC;EACjB,OAAOA,WAAW;AACpB,CAAC;AAED,MAAME,wBAAwB,GAAG3U,OAAO,IAAI;EAC1C,IAAI4U,iBAAiB;EACrB,MAAM9X,IAAI,GAAGD,uBAAuB,CAAC,CAACmD,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAClD,IAAI,KAAK,SAAS,CAAC;EACnH,MAAMsD,IAAI,GAAG,IAAI5I,aAAa,CAACsF,IAAI,CAAC;;EAEpC;EACAsD,IAAI,CAACyU,QAAQ,GAAG,CAACD,iBAAiB,GAAG5U,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC6U,QAAQ,MAAM,IAAI,IAAID,iBAAiB,KAAK,KAAK,CAAC,GAAGA,iBAAiB,GAAG,IAAI;EAC5K,OAAOxU,IAAI;AACb,CAAC;AACD,MAAM0U,oBAAoB,GAAGA,CAAC;EAC5B1J,SAAS;EACTlI,MAAM;EACNkM,SAAS;EACT2F,SAAS;EACTlP,UAAU;EACV0J,QAAQ,EAAEyF,SAAS,GAAG;AACxB,CAAC,KAAK;EACJ9R,MAAM,CAACQ,iBAAiB,CAAC,IAAI,EAAE,KAAK,CAAC;EACrC,MAAM4L,mBAAmB,GAAGpM,MAAM,CAACC,MAAM,CAACI,WAAW,CAACC,KAAK,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC;EACtE,OAAO;IACLP,MAAM;IACNkI,SAAS;IACTkE,mBAAmB;IACnBF,SAAS,EAAEA,SAAS,GAAGA,SAAS,GAAG6F,MAAM,IAAI;MAC3C/R,MAAM,CAAC+R,MAAM,CAACtR,IAAI,CAACsR,MAAM,CAAC;IAC5B,CAAC;IACDF,SAAS,EAAEA,SAAS,GAAGA,SAAS,GAAGE,MAAM,IAAIA,MAAM,CAACtR,IAAI,CAACT,MAAM,CAAC+R,MAAM,CAAC;IACvEhY,KAAK,EAAE4I,UAAU,IAAI3C,MAAM,CAACE,aAAa,CAAC3H,MAAM,CAAC,CAAC+H,KAAK,CAAC,CAAC;IACzDyL,UAAU,EAAE,KAAK;IACjBM,QAAQ,EAAEyF;EACZ,CAAC;AACH,CAAC;AACD,MAAME,yBAAyB,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,UAAU,CAAC;AACnE,MAAMC,uBAAuB,GAAG;EAC9BC,YAAY,EAAEA,CAACC,EAAE,EAAEnb,KAAK,KAAK;IAC3Bmb,EAAE,CAACC,eAAe,CAACpb,KAAK,EAAE,IAAI,CAAC;EACjC,CAAC;EACDqb,0BAA0BA,CAACF,EAAE,EAAEnb,KAAK,EAAE;IACpCmb,EAAE,CAACG,6BAA6B,CAACtb,KAAK,CAAC;EACzC,CAAC;EACDub,aAAa,EAAEA,CAACJ,EAAE,EAAEnb,KAAK,KAAK;IAC5Bmb,EAAE,CAACK,gBAAgB,CAACxb,KAAK,CAAC;EAC5B,CAAC;EACDyb,cAAc,EAAEA,CAACN,EAAE,EAAEnb,KAAK,KAAK;IAC7Bmb,EAAE,CAACO,iBAAiB,CAAC1b,KAAK,CAAC;EAC7B,CAAC;EACD2b,cAAc,EAAEA,CAACR,EAAE,EAAEnb,KAAK,KAAK;IAC7Bmb,EAAE,CAACS,iBAAiB,CAAC5b,KAAK,CAAC;EAC7B,CAAC;EACD6b,gBAAgB,EAAEA,CAACV,EAAE,EAAE,CAACzZ,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,KAAK;IACnCuZ,EAAE,CAACW,mBAAmB,CAACpa,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE,IAAI,CAAC;EACvC,CAAC;EACDma,mBAAmB,EAAEA,CAACZ,EAAE,EAAE,CAACzZ,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,KAAK;IACtCuZ,EAAE,CAACa,sBAAsB,CAACta,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE,IAAI,CAAC;EAC1C,CAAC;EACDqa,aAAa,EAAEA,CAACd,EAAE,EAAEnb,KAAK,KAAK;IAC5Bmb,EAAE,CAACc,aAAa,CAACjc,KAAK,EAAE,IAAI,CAAC;EAC/B,CAAC;EACDkc,gBAAgB,EAAEA,CAACf,EAAE,EAAEnb,KAAK,KAAK;IAC/Bmb,EAAE,CAACe,gBAAgB,CAAClc,KAAK,EAAE,IAAI,CAAC;EAClC,CAAC;EACDmc,eAAe,EAAEA,CAAChB,EAAE,EAAE,CAACzZ,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,KAAK;IAClCuZ,EAAE,CAACiB,SAAS,CAAC;MACX1a,CAAC;MACDC,CAAC;MACDC;IACF,CAAC,EAAE,IAAI,CAAC;EACV,CAAC;EACDya,cAAc,EAAEA,CAAClB,EAAE,EAAE,CAACzZ,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,KAAK;IACjCuZ,EAAE,CAACmB,SAAS,CAAC;MACX5a,CAAC;MACDC,CAAC;MACDC;IACF,CAAC,EAAE,IAAI,CAAC;EACV,CAAC;EACD2a,GAAG,EAAEA,CAACpB,EAAE,EAAEnb,KAAK,KAAK;IAClBmb,EAAE,CAACqB,SAAS,CAACxc,KAAK,CAAC;EACrB,CAAC;EACDyc,iBAAiB,EAAEA,CAACtB,EAAE,EAAEnb,KAAK,KAAK;IAChCmb,EAAE,CAACuB,oBAAoB,CAAC1c,KAAK,CAAC;EAChC,CAAC;EACD4K,QAAQ,EAAEA,CAACuQ,EAAE,EAAEnb,KAAK,KAAK;IACvBmb,EAAE,CAACvQ,QAAQ,GAAG5K,KAAK;EACrB,CAAC;EACD4C,IAAIA,CAACuY,EAAE,EAAEnb,KAAK,EAAE;IACdmb,EAAE,CAACwB,WAAW,CAACha,uBAAuB,CAAC3C,KAAK,CAAC,EAAE,IAAI,CAAC;EACtD,CAAC;EACDsI,QAAQ,EAAEA,CAAA,KAAM,CAAC,CAAC;EAClBC,QAAQ,EAAEA,CAAA,KAAM,CAAC,CAAC;EAClBF,UAAU,EAAEA,CAAA,KAAM,CAAC,CAAC;EACpBtF,KAAK,EAAEA,CAAA,KAAM,CAAC;AAChB,CAAC;AACD,MAAM6Z,0BAA0B,GAAG9c,MAAM,CAACO,IAAI,CAAC4a,uBAAuB,CAAC;AACvE,MAAM4B,mBAAmB,GAAGA,CAAC3L,SAAS,EAAEpL,OAAO,EAAE4C,MAAM,EAAEoU,kBAAkB,GAAG,IAAI,KAAK;EACrF,IAAI,CAAC5L,SAAS,EAAE;IACd;EACF;EACA,MAAMvI,KAAK,GAAGD,MAAM,CAACE,GAAG,CAACsI,SAAS,CAACrI,MAAM,CAAC;EAC1C,IAAIF,KAAK,EAAE;IACT,IAAImU,kBAAkB,EAAE;MACtBnU,KAAK,CAACK,MAAM,CAACQ,iBAAiB,CAAC,IAAI,EAAE,KAAK,CAAC;MAC3CpI,QAAQ,CAACqI,IAAI,CAACd,KAAK,CAACK,MAAM,CAACK,WAAW,CAAC,CAACM,SAAS,CAACtI,SAAS,EAAEC,SAAS,EAAEC,MAAM,CAAC;MAC/E2P,SAAS,CAACpH,cAAc,CAACzI,SAAS,EAAE,KAAK,CAAC;MAC1C6P,SAAS,CAACnH,WAAW,CAACzI,SAAS,EAAE,KAAK,CAAC;IACzC;IACAsb,0BAA0B,CAAC7b,OAAO,CAACiJ,GAAG,IAAI;MACxC,IAAIA,GAAG,IAAIlE,OAAO,EAAE;QAClBmV,uBAAuB,CAACjR,GAAG,CAAC,CAACkH,SAAS,EAAEpL,OAAO,CAACkE,GAAG,CAAC,CAAC;MACvD;IACF,CAAC,CAAC;EACJ;AACF,CAAC;AACD,MAAM+S,yBAAyB,GAAGA,CAAC/W,YAAY,EAAEoE,KAAK,EAAE1B,MAAM,EAAEoU,kBAAkB,GAAG,IAAI,KAAK;EAC5F;EACA,MAAMzS,uBAAuB,GAAGnM,OAAO,CAAC,MAAM0e,0BAA0B,CAACtS,OAAO,CAACN,GAAG,IAAI;IACtF,OAAO9G,aAAa,CAACkH,KAAK,CAACJ,GAAG,CAAC,CAAC;EAClC,CAAC,CAAC,EAAE,CAACI,KAAK,CAAC,CAAC;EACZpM,SAAS,CAAC,MAAM;IACd,MAAMkT,SAAS,GAAGlL,YAAY,CAAC,CAAC;IAChC6W,mBAAmB,CAAC3L,SAAS,EAAE9G,KAAK,EAAE1B,MAAM,EAAEoU,kBAAkB,CAAC;EACnE,CAAC,EAAEzS,uBAAuB,CAAC;AAC7B,CAAC;AACD,MAAM2S,kBAAkB,GAAGA,CAAChX,YAAY,EAAEoE,KAAK,EAAE0D,MAAM,KAAK;EAC1D,MAAM;IACJgH,MAAM;IACND,OAAO;IACPtH,gBAAgB;IAChBC,eAAe;IACfC,mBAAmB;IACnBC,kBAAkB;IAClBE;EACF,CAAC,GAAGxD,KAAK;EACT,MAAM6S,aAAa,GAAG;IACpBnI,MAAM;IACND,OAAO;IACPtH,gBAAgB;IAChBC,eAAe;IACfC,mBAAmB;IACnBC,kBAAkB;IAClBE;EACF,CAAC;EACD5P,SAAS,CAAC,MAAM;IACd,MAAMkT,SAAS,GAAGlL,YAAY,CAAC,CAAC;IAChC8H,MAAM,CAAC/L,GAAG,CAACmP,SAAS,CAACrI,MAAM,EAAEoU,aAAa,CAAC;IAC3C,OAAO,MAAM;MACXnP,MAAM,CAACS,MAAM,CAAC2C,SAAS,CAACrI,MAAM,CAAC;IACjC,CAAC;EACH,CAAC,EAAE,CAACiM,MAAM,EAAED,OAAO,EAAEtH,gBAAgB,EAAEC,eAAe,EAAEC,mBAAmB,EAAEC,kBAAkB,EAAEE,cAAc,CAAC,CAAC;AACnH,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMsP,IAAI,GAAGA,CAAC;EACZxb,CAAC;EACDC,CAAC;EACDC;AACF,CAAC,GAAG;EACFF,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE;AACL,CAAC,KAAK;EACJ,OAAO,IAAI7E,OAAO,CAAC2E,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;AAC7B,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMub,IAAI,GAAGA,CAAC;EACZzb,CAAC;EACDC,CAAC;EACDC,CAAC;EACDE;AACF,CAAC,GAAG;EACFJ,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE,CAAC;EACJE,CAAC,EAAE;AACL,CAAC,KAAK;EACJ,OAAO,IAAI7E,UAAU,CAACyE,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEE,CAAC,CAAC;AACnC,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMsb,KAAK,GAAGA,CAAC;EACb1b,CAAC;EACDC,CAAC;EACDC;AACF,CAAC,GAAG;EACFF,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE;AACL,CAAC,KAAK;EACJ,OAAO,IAAIpD,KAAK,CAACkD,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMyb,WAAW,GAAG,aAAapf,IAAI,CAACmM,KAAK,IAAI;EAC7C,MAAM;IACJmH,QAAQ;IACRjJ,QAAQ;IACRC,QAAQ;IACRF,UAAU;IACVtF,KAAK;IACLua;EACF,CAAC,GAAGlT,KAAK;EACT,MAAM;IACJrE,KAAK;IACL6M,cAAc;IACdF;EACF,CAAC,GAAG/D,SAAS,CAAC,CAAC;EACf,MAAM4O,gBAAgB,GAAGC,mBAAmB,CAAC,CAAC;EAC9C,MAAMC,WAAW,GAAG1D,eAAe,CAAC3P,KAAK,CAAC/G,GAAG,CAAC;EAC9C,MAAMqa,SAAS,GAAG3f,MAAM,CAAC,IAAI,CAAC;;EAE9B;EACA,MAAM4f,kBAAkB,GAAGvX,wBAAwB,CAACkE,OAAO,CAACN,GAAG;EAC/D;EACA9H,KAAK,CAACC,OAAO,CAACiI,KAAK,CAACJ,GAAG,CAAC,CAAC,GAAGI,KAAK,CAACJ,GAAG,CAAC,GAAG,CAACI,KAAK,CAACJ,GAAG,CAAC,CAAC,CAAC;EACtD,MAAMuQ,WAAW,GAAGJ,qBAAqB,CAAC,MAAM;IAC9C,MAAMxO,UAAU,GAAG+R,SAAS,CAACna,OAAO,CAAC2F,aAAa,CAACgU,IAAI,CAAC,CAAC,CAAC;IAC1D,MAAM3W,QAAQ,GAAGV,yBAAyB,CAACuE,KAAK,EAAErE,KAAK,EAAE4F,UAAU,EAAE4R,gBAAgB,KAAK,IAAI,IAAIA,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACvX,YAAY,CAAC;IACvK,IAAI,OAAOoE,KAAK,CAAC/G,GAAG,IAAI,UAAU,EAAE;MAClC+G,KAAK,CAAC/G,GAAG,CAACkD,QAAQ,CAAC;IACrB;IACAkX,WAAW,CAACla,OAAO,GAAGgD,QAAQ;IAC9B,OAAOA,QAAQ;EACjB,CAAC,EAAEA,QAAQ,IAAI;IACb,IAAIR,KAAK,CAACoE,WAAW,CAAC5D,QAAQ,CAACsC,MAAM,CAAC,EAAE;MACtC9C,KAAK,CAAC6X,cAAc,CAACrX,QAAQ,EAAE,IAAI,CAAC;IACtC;EACF,CAAC,EAAE,CAAC,GAAGoX,kBAAkB,EAAEJ,gBAAgB,CAAC,CAAC;EAC7Cvf,SAAS,CAAC,MAAM;IACd,MAAMuI,QAAQ,GAAGgU,WAAW,CAAC,CAAC;IAC9B7H,cAAc,CAAC3Q,GAAG,CAACwE,QAAQ,CAACsC,MAAM,EAAEiC,mBAAmB,CAACvE,QAAQ,EAAEmX,SAAS,CAACna,OAAO,EAAEga,gBAAgB,KAAK,IAAI,IAAIA,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACla,GAAG,CAACE,OAAO,CAAC,CAAC;IACvL,OAAO,MAAM;MACXmP,cAAc,CAACnE,MAAM,CAAChI,QAAQ,CAACsC,MAAM,CAAC;IACxC,CAAC;EACH,CAAC,EAAE,CAAC0R,WAAW,CAAC,CAAC;EACjB,MAAMsD,WAAW,GAAG3f,OAAO,CAAC,MAAM;IAChC,OAAO0C,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEuL,8BAA8B,CAACoR,gBAAgB,KAAK,IAAI,IAAIA,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACzX,OAAO,CAAC,CAAC,EAAEsE,KAAK,CAAC;EAChL,CAAC,EAAE,CAACA,KAAK,EAAEmT,gBAAgB,KAAK,IAAI,IAAIA,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACzX,OAAO,CAAC,CAAC;EACzGoE,wBAAwB,CAACqQ,WAAW,EAAEsD,WAAW,EAAEnL,cAAc,CAAC;EAClE7E,iBAAiB,CAAC0M,WAAW,EAAEsD,WAAW,EAAEjL,cAAc,EAAEvF,iCAAiC,CAACkQ,gBAAgB,KAAK,IAAI,IAAIA,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACzX,OAAO,CAAC,CAAC;EAC5L,OAAO,aAAahI,KAAK,CAAC4G,aAAa,CAAC,UAAU,EAAE;IAClD4D,QAAQ,EAAEA,QAAQ;IAClBC,QAAQ,EAAEA,QAAQ;IAClBF,UAAU,EAAEA,UAAU;IACtBtF,KAAK,EAAEA,KAAK;IACZM,GAAG,EAAEqa,SAAS;IACdJ,IAAI,EAAEA;EACR,CAAC,EAAE/L,QAAQ,CAAC;AACd,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA,MAAMuM,cAAc,GAAG,aAAahgB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK;EACnE,OAAO,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;IACvEhF,KAAK,EAAE,QAAQ;IACf/B,GAAG,EAAEA;EACP,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AACFya,cAAc,CAACE,WAAW,GAAG,gBAAgB;AAC7C;AACA;AACA;AACA;AACA,MAAMC,mBAAmB,GAAG,aAAangB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EAC1IhF,KAAK,EAAE,aAAa;EACpB/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJ4a,mBAAmB,CAACD,WAAW,GAAG,qBAAqB;AACvD;AACA;AACA;AACA;AACA,MAAME,YAAY,GAAG,aAAapgB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EACnIhF,KAAK,EAAE,MAAM;EACb/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJ6a,YAAY,CAACF,WAAW,GAAG,cAAc;AACzC;AACA;AACA;AACA;AACA,MAAMG,eAAe,GAAG,aAAargB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EACtIhF,KAAK,EAAE,SAAS;EAChB/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJ8a,eAAe,CAACH,WAAW,GAAG,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,MAAMI,mBAAmB,GAAG,aAAatgB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EAC1IhF,KAAK,EAAE,aAAa;EACpB/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJ+a,mBAAmB,CAACJ,WAAW,GAAG,qBAAqB;AACvD;AACA;AACA;AACA;AACA,MAAMK,eAAe,GAAG,aAAavgB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EACtIhF,KAAK,EAAE,SAAS;EAChB/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJgb,eAAe,CAACL,WAAW,GAAG,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,MAAMM,YAAY,GAAG,aAAaxgB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EACnIhF,KAAK,EAAE,MAAM;EACb/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJib,YAAY,CAACN,WAAW,GAAG,cAAc;AACzC;AACA;AACA;AACA;AACA,MAAMO,iBAAiB,GAAG,aAAazgB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EACxIhF,KAAK,EAAE,WAAW;EAClB/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJkb,iBAAiB,CAACP,WAAW,GAAG,mBAAmB;AACnD;AACA;AACA;AACA;AACA,MAAMQ,gBAAgB,GAAG,aAAa1gB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EACvIhF,KAAK,EAAE,UAAU;EACjB/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJmb,gBAAgB,CAACR,WAAW,GAAG,kBAAkB;AACjD;AACA;AACA;AACA;AACA,MAAMS,qBAAqB,GAAG,aAAa3gB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EAC5IhF,KAAK,EAAE,eAAe;EACtB/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJmb,gBAAgB,CAACR,WAAW,GAAG,uBAAuB;AACtD;AACA;AACA;AACA;AACA,MAAMU,kBAAkB,GAAG,aAAa5gB,KAAK,CAACigB,UAAU,CAAC,CAAC3T,KAAK,EAAE/G,GAAG,KAAK,aAAavF,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC,CAAC,CAAC,EAAExP,KAAK,EAAE;EACzIhF,KAAK,EAAE,YAAY;EACnB/B,GAAG,EAAEA;AACP,CAAC,CAAC,CAAC,CAAC;AACJqb,kBAAkB,CAACV,WAAW,GAAG,oBAAoB;AAErD,MAAMW,WAAW,GAAG,CAAC,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,EAAE,YAAY,EAAE,gBAAgB,CAAC;AAChH,MAAMC,gBAAgB,GAAG,aAAavgB,aAAa,CAACiF,SAAS,CAAC;AAC9D,MAAMka,mBAAmB,GAAGA,CAAA,KAAMrf,UAAU,CAACygB,gBAAgB,CAAC;AAC9D;AACA;AACA;AACA;AACA,MAAMlhB,SAAS,GAAG,aAAaO,IAAI,CAACmM,KAAK,IAAI;EAC3C,MAAM;MACF/G,GAAG;MACHkO,QAAQ;MACR3O,IAAI;MACJ0F,QAAQ;MACRC,QAAQ;MACRxF,KAAK;MACLsF,UAAU;MACVwW;IACF,CAAC,GAAGzU,KAAK;IACT0U,WAAW,GAAG9Z,wBAAwB,CAACoF,KAAK,EAAEuU,WAAW,CAAC;EAC5D,MAAMjB,SAAS,GAAG3f,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMghB,YAAY,GAAGhF,eAAe,CAAC1W,GAAG,CAAC;EACzC,MAAM;IACJ0C,KAAK;IACLyM,eAAe;IACf+G,cAAc;IACd5G;EACF,CAAC,GAAGhE,SAAS,CAAC,CAAC;EACf,MAAMqQ,aAAa,GAAG9gB,OAAO,CAAC,MAAM;IAClC,OAAO0C,cAAc,CAACA,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAE2Y,cAAc,CAAC,EAAEnP,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;MACnFmH,QAAQ,EAAEjO;IACZ,CAAC,CAAC;EACJ,CAAC,EAAE,CAACiW,cAAc,EAAEnP,KAAK,CAAC,CAAC;EAC3B,MAAMuT,kBAAkB,GAAG3C,yBAAyB,CAAC1Q,OAAO,CAACN,GAAG,IAAI;IAClE,OAAO9H,KAAK,CAACC,OAAO,CAAC6c,aAAa,CAAChV,GAAG,CAAC,CAAC,GAAG,CAAC,GAAGgV,aAAa,CAAChV,GAAG,CAAC,CAAC,GAAGgV,aAAa,CAAChV,GAAG,CAAC;EACzF,CAAC,CAAC;EACF,MAAMwB,kBAAkB,GAAG2D,qBAAqB,CAACuO,SAAS,EAAEsB,aAAa,CAAC;;EAE1E;EACA,MAAMhZ,YAAY,GAAGmU,qBAAqB,CAAC,MAAM;IAC/C,MAAMjU,IAAI,GAAGuU,wBAAwB,CAACuE,aAAa,CAAC;IACpD,MAAM9N,SAAS,GAAGnL,KAAK,CAACkZ,eAAe,CAAC/Y,IAAI,CAAC;IAC7C,IAAI,OAAO7C,GAAG,KAAK,UAAU,EAAE;MAC7BA,GAAG,CAAC6N,SAAS,CAAC;IAChB;IACA6N,YAAY,CAACxb,OAAO,GAAG2N,SAAS;IAChC,OAAOA,SAAS;EAClB,CAAC,EAAEA,SAAS,IAAI;IACd,IAAInL,KAAK,CAACC,YAAY,CAACkL,SAAS,CAACrI,MAAM,CAAC,EAAE;MACxC9C,KAAK,CAACmZ,eAAe,CAAChO,SAAS,CAAC;IAClC;EACF,CAAC,EAAEyM,kBAAkB,CAAC;;EAEtB;EACA3f,SAAS,CAAC,MAAM;IACd,MAAMkT,SAAS,GAAGlL,YAAY,CAAC,CAAC;IAChC,MAAM2C,KAAK,GAAGiS,oBAAoB,CAAC;MACjC1J,SAAS;MACTlI,MAAM,EAAE0U,SAAS,CAACna;IACpB,CAAC,CAAC;IACFiP,eAAe,CAACzQ,GAAG,CAACmP,SAAS,CAACrI,MAAM,EAAEuB,KAAK,CAACyU,cAAc,GAAGzU,KAAK,CAACyU,cAAc,CAAClW,KAAK,CAAC,GAAGA,KAAK,CAAC;IACjG,OAAO,MAAM;MACX6J,eAAe,CAACjE,MAAM,CAAC2C,SAAS,CAACrI,MAAM,CAAC;IAC1C,CAAC;EACH,CAAC,EAAE,CAAC7C,YAAY,CAAC,CAAC;EAClB+W,yBAAyB,CAAC/W,YAAY,EAAEgZ,aAAa,EAAExM,eAAe,CAAC;EACvEwK,kBAAkB,CAAChX,YAAY,EAAEgZ,aAAa,EAAErM,eAAe,CAAC;EAChE,MAAMwM,YAAY,GAAGjhB,OAAO,CAAC,MAAM;IACjC,OAAO;MACLmF,GAAG,EAAEqa,SAAS;MACd1X,YAAY,EAAEA,YAAY;MAC1BF,OAAO,EAAEkZ;IACX,CAAC;EACH,CAAC,EAAE,CAAChZ,YAAY,CAAC,CAAC;EAClB,OAAO,aAAalI,KAAK,CAAC4G,aAAa,CAACka,gBAAgB,CAACjF,QAAQ,EAAE;IACjE3Z,KAAK,EAAEmf;EACT,CAAC,EAAE,aAAarhB,KAAK,CAAC4G,aAAa,CAAC,UAAU,EAAEkV,QAAQ,CAAC;IACvDvW,GAAG,EAAEqa;EACP,CAAC,EAAEoB,WAAW,EAAE;IACdxW,QAAQ,EAAEA,QAAQ;IAClBC,QAAQ,EAAEA,QAAQ;IAClBF,UAAU,EAAEA,UAAU;IACtBtF,KAAK,EAAEA;EACT,CAAC,CAAC,EAAEwO,QAAQ,EAAE/F,kBAAkB,CAAC9F,GAAG,CAAC,CAACwG,aAAa,EAAEtG,KAAK,KAAK,aAAa9H,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC;IACpH5P,GAAG,EAAEpE;EACP,CAAC,EAAEsG,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;AACvB,CAAC,CAAC;AACFxO,SAAS,CAACsgB,WAAW,GAAG,WAAW;;AAEnC;AACA;AACA;AACA;AACA,MAAMoB,YAAY,GAAG,aAAanhB,IAAI,CAACmM,KAAK,IAAI;EAC9C,MAAM;IACJmH,QAAQ;IACR3O;EACF,CAAC,GAAGwH,KAAK;EACT,MAAM;IACJmP;EACF,CAAC,GAAG5K,SAAS,CAAC,CAAC;EACf,MAAM3F,MAAM,GAAGjL,MAAM,CAAC,IAAI,CAAC;EAC3B,MAAM;IACJ+H;EACF,CAAC,GAAG0X,mBAAmB,CAAC,CAAC;EACzB,MAAMwB,aAAa,GAAG9gB,OAAO,CAAC,MAAM;IAClC,OAAO0C,cAAc,CAACA,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAE2Y,cAAc,CAAC,EAAEzT,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE;MACrFyL,QAAQ,EAAEjO,SAAS;MACnBsI,SAAS,EAAEhJ;IACb,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC2W,cAAc,EAAEzT,OAAO,CAAC,CAAC;EAC7B,MAAM0F,kBAAkB,GAAG2D,qBAAqB,CAACnG,MAAM,EAAEgW,aAAa,EAAE,KAAK,CAAC;EAC9E,OAAO,aAAalhB,KAAK,CAAC4G,aAAa,CAAC,UAAU,EAAE;IAClDrB,GAAG,EAAE2F,MAAM;IACX4B,QAAQ,EAAE;MACRC,YAAY,EAAE;IAChB;EACF,CAAC,EAAE0G,QAAQ,EAAE/F,kBAAkB,CAAC9F,GAAG,CAAC,CAACwG,aAAa,EAAEtG,KAAK,KAAK,aAAa9H,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC;IACnH5P,GAAG,EAAEpE;EACP,CAAC,EAAEsG,aAAa,CAAC,CAAC,CAAC,CAAC;AACtB,CAAC,CAAC;AACFkT,YAAY,CAACpB,WAAW,GAAG,cAAc;AAEzC,MAAMqB,SAAS,GAAG,CAAC,KAAK,CAAC;EACvBC,UAAU,GAAG,CAAC,UAAU,EAAE,WAAW,EAAE,eAAe,EAAE,UAAU,EAAE,UAAU,EAAE,YAAY,EAAE,OAAO,CAAC;AACxG,MAAMC,oBAAoB,GAAG,aAAathB,IAAI,CAACuhB,IAAI,IAAI;EACrD,IAAI;MACAnc;IACF,CAAC,GAAGmc,IAAI;IACRpV,KAAK,GAAGpF,wBAAwB,CAACwa,IAAI,EAAEH,SAAS,CAAC;EACnD,MAAMI,cAAc,GAAG1F,eAAe,CAAC1W,GAAG,EAAE,EAAE,CAAC;EAC/C,MAAMqa,SAAS,GAAG3f,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAM2hB,kBAAkB,GAAG3hB,MAAM,CAAC,IAAI,CAAC;EACvC,MAAM;MACF;MACAwT,QAAQ;MACRoO,SAAS;MACTC,aAAa,GAAG,EAAE;MAClB;MACAtX,QAAQ;MACRC,QAAQ;MACRF,UAAU;MACVtF;;MAEA;IACF,CAAC,GAAGqH,KAAK;IACTyV,cAAc,GAAG7a,wBAAwB,CAACoF,KAAK,EAAEkV,UAAU,CAAC;EAC9D,MAAM9T,kBAAkB,GAAG2D,qBAAqB,CAACuO,SAAS,EAAE9c,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAEwJ,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;IACxGmH,QAAQ,EAAEjO;EACZ,CAAC,CAAC,CAAC;EACH,MAAMwc,gBAAgB,GAAGA,CAAA,KAAM;IAC7B,MAAMC,UAAU,GAAGL,kBAAkB,CAACnc,OAAO,CAACgO,QAAQ,CAAC,CAAC,CAAC;IACzD,IAAIwO,UAAU,IAAI,iBAAiB,IAAIA,UAAU,EAAE;MACjD,OAAOA,UAAU;IACnB;IACA,OAAOzc,SAAS;EAClB,CAAC;EACDtF,SAAS,CAAC,MAAM;IACd,MAAMgiB,aAAa,GAAGF,gBAAgB,CAAC,CAAC;IACxC,IAAIE,aAAa,EAAE;MACjBA,aAAa,CAACC,cAAc,CAACC,QAAQ,CAACphB,gBAAgB,CAAC;IACzD,CAAC,MAAM;MACLqhB,OAAO,CAACC,IAAI,CAAC,gFAAgF,CAAC;IAChG;EACF,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMC,mBAAmB,GAAGA,CAAC1X,KAAK,EAAE/C,KAAK,KAAK;IAC5C,MAAMoa,aAAa,GAAGF,gBAAgB,CAAC,CAAC;IACxC,IAAIE,aAAa,EAAE;MACjB,OAAOpf,cAAc,CAACA,cAAc,CAAC,CAAC,CAAC,EAAE+H,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;QACnDkS,SAAS,EAAEE,MAAM,IAAI;UACnBiF,aAAa,CAACM,WAAW,CAAC1a,KAAK,EAAEmV,MAAM,CAAC;UACxC,OAAOA,MAAM;QACf,CAAC;QACD7F,SAAS,EAAE6F,MAAM,IAAI;UACnBiF,aAAa,CAACO,WAAW,CAAC3a,KAAK,EAAEmV,MAAM,CAAC;UACxCiF,aAAa,CAACC,cAAc,CAACO,WAAW,GAAG,IAAI;QACjD,CAAC;QACDnL,QAAQ,EAAE;MACZ,CAAC,CAAC;IACJ;IACA,OAAO1M,KAAK;EACd,CAAC;EACD,OAAO,aAAa7K,KAAK,CAAC4G,aAAa,CAAC,UAAU,EAAEkV,QAAQ,CAAC;IAC3DvW,GAAG,EAAEqa;EACP,CAAC,EAAEmC,cAAc,EAAE;IACjBvX,QAAQ,EAAEA,QAAQ;IAClBC,QAAQ,EAAEA,QAAQ;IAClBF,UAAU,EAAEA,UAAU;IACtBtF,KAAK,EAAEA;EACT,CAAC,CAAC,EAAE,aAAajF,KAAK,CAAC4G,aAAa,CAAC,UAAU,EAAE;IAC/CrB,GAAG,EAAEqc;EACP,CAAC,EAAEnO,QAAQ,CAAC,EAAEoO,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACja,GAAG,CAAC,CAACuK,QAAQ,EAAErK,KAAK,KAAK,aAAa9H,KAAK,CAAC4G,aAAa,CAAChH,SAAS,EAAEkc,QAAQ,CAAC,CAAC,CAAC,EAAEiG,cAAc,EAAE5P,QAAQ,EAAE;IACxL5M,GAAG,EAAEqR,IAAI,IAAI;MACX+K,cAAc,CAAClc,OAAO,CAACqC,KAAK,CAAC,GAAG8O,IAAI;IACtC,CAAC;IACDmK,cAAc,EAAElW,KAAK,IAAI0X,mBAAmB,CAAC1X,KAAK,EAAE/C,KAAK;EAC3D,CAAC,CAAC,EAAE,aAAa9H,KAAK,CAAC4G,aAAa,CAAC5G,KAAK,CAACS,QAAQ,EAAE,IAAI,EAAEqhB,aAAa,CAACla,GAAG,CAAC,CAAC+a,IAAI,EAAE7a,KAAK,KAAK,aAAa9H,KAAK,CAAC4G,aAAa,CAACnG,QAAQ,EAAE;IACvIyL,GAAG,EAAEpE;EACP,CAAC,EAAE6a,IAAI,CAAC,CAAC,EAAEjV,kBAAkB,CAAC9F,GAAG,CAAC,CAACwG,aAAa,EAAEwU,aAAa,KAAK,aAAa5iB,KAAK,CAAC4G,aAAa,CAAC2Y,WAAW,EAAEzD,QAAQ,CAAC;IACzH5P,GAAG,EAAE0W;EACP,CAAC,EAAExU,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,CAAC,CAAC;AACFqT,oBAAoB,CAACvB,WAAW,GAAG,sBAAsB;;AAEzD;AACA;AACA;AACA,MAAM2C,eAAe,GAAGA,CAACC,KAAK,EAAEC,KAAK,EAAEC,MAAM,KAAK;EAChD,MAAM;IACJ/a;EACF,CAAC,GAAG4I,SAAS,CAAC,CAAC;EACf,MAAMoS,QAAQ,GAAGhjB,MAAM,CAACuF,SAAS,CAAC;EAClC6W,qBAAqB,CAAC,MAAM;IAC1B,IAAIyG,KAAK,CAACrd,OAAO,IAAIsd,KAAK,CAACtd,OAAO,EAAE;MAClC,MAAMyd,QAAQ,GAAGjb,KAAK,CAACkb,kBAAkB,CAACH,MAAM,EAAEF,KAAK,CAACrd,OAAO,EAAEsd,KAAK,CAACtd,OAAO,EAAE,IAAI,CAAC;MACrFwd,QAAQ,CAACxd,OAAO,GAAGyd,QAAQ;MAC3B,OAAOA,QAAQ;IACjB;EACF,CAAC,EAAEE,KAAK,IAAI;IACV,IAAIA,KAAK,EAAE;MACTH,QAAQ,CAACxd,OAAO,GAAGD,SAAS;MAC5B,IAAIyC,KAAK,CAACob,eAAe,CAACD,KAAK,CAACrY,MAAM,CAAC,EAAE;QACvC9C,KAAK,CAACqb,kBAAkB,CAACF,KAAK,EAAE,IAAI,CAAC;MACvC;IACF;EACF,CAAC,EAAE,EAAE,CAAC;EACN,OAAOH,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMM,aAAa,GAAGA,CAACT,KAAK,EAAEC,KAAK,EAAE,CAACS,WAAW,EAAEC,eAAe,EAAEC,WAAW,EAAEC,eAAe,CAAC,KAAK;EACpG,MAAM;IACJ7S;EACF,CAAC,GAAGD,SAAS,CAAC,CAAC;EACf,OAAOgS,eAAe,CAACC,KAAK,EAAEC,KAAK,EAAEjS,MAAM,CAAC8S,SAAS,CAACnf,KAAK,CAACP,qBAAqB,CAACsf,WAAW,CAAC,EAAEjf,4BAA4B,CAACkf,eAAe,CAAC,EAAEvf,qBAAqB,CAACwf,WAAW,CAAC,EAAEnf,4BAA4B,CAACof,eAAe,CAAC,CAAC,CAAC;AACpO,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,iBAAiB,GAAGA,CAACf,KAAK,EAAEC,KAAK,EAAE,CAACS,WAAW,EAAEE,WAAW,CAAC,KAAK;EACtE,MAAM;IACJ5S;EACF,CAAC,GAAGD,SAAS,CAAC,CAAC;EACf,OAAOgS,eAAe,CAACC,KAAK,EAAEC,KAAK,EAAEjS,MAAM,CAAC8S,SAAS,CAACE,SAAS,CAAC5f,qBAAqB,CAACsf,WAAW,CAAC,EAAEtf,qBAAqB,CAACwf,WAAW,CAAC,CAAC,CAAC;AAC1I,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,gBAAgB,GAAGA,CAACjB,KAAK,EAAEC,KAAK,EAAE,CAACS,WAAW,EAAEE,WAAW,EAAEM,IAAI,EAAEC,MAAM,CAAC,KAAK;EACnF,MAAM;IACJnT;EACF,CAAC,GAAGD,SAAS,CAAC,CAAC;EACf,MAAMmS,MAAM,GAAGlS,MAAM,CAAC8S,SAAS,CAACM,QAAQ,CAAChgB,qBAAqB,CAACsf,WAAW,CAAC,EAAEtf,qBAAqB,CAACwf,WAAW,CAAC,EAAExf,qBAAqB,CAAC8f,IAAI,CAAC,CAAC;EAC7I,IAAIC,MAAM,EAAE;IACVjB,MAAM,CAACmB,aAAa,GAAG,IAAI;IAC3BnB,MAAM,CAACiB,MAAM,GAAGA,MAAM;EACxB;EACA,OAAOpB,eAAe,CAACC,KAAK,EAAEC,KAAK,EAAEC,MAAM,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMoB,iBAAiB,GAAGA,CAACtB,KAAK,EAAEC,KAAK,EAAE,CAACS,WAAW,EAAEE,WAAW,EAAEM,IAAI,EAAEC,MAAM,CAAC,KAAK;EACpF,MAAM;IACJnT;EACF,CAAC,GAAGD,SAAS,CAAC,CAAC;EACf,MAAMmS,MAAM,GAAGlS,MAAM,CAAC8S,SAAS,CAACS,SAAS,CAACngB,qBAAqB,CAACsf,WAAW,CAAC,EAAEtf,qBAAqB,CAACwf,WAAW,CAAC,EAAExf,qBAAqB,CAAC8f,IAAI,CAAC,CAAC;EAC9I,IAAIC,MAAM,EAAE;IACVjB,MAAM,CAACmB,aAAa,GAAG,IAAI;IAC3BnB,MAAM,CAACiB,MAAM,GAAGA,MAAM;EACxB;EACA,OAAOpB,eAAe,CAACC,KAAK,EAAEC,KAAK,EAAEC,MAAM,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMsB,YAAY,GAAGA,CAACxB,KAAK,EAAEC,KAAK,EAAE,CAACS,WAAW,EAAEE,WAAW,EAAE1gB,MAAM,CAAC,KAAK;EACzE,MAAM;IACJ8N;EACF,CAAC,GAAGD,SAAS,CAAC,CAAC;EACf,MAAM0T,YAAY,GAAGrgB,qBAAqB,CAACsf,WAAW,CAAC;EACvD,MAAMgB,YAAY,GAAGtgB,qBAAqB,CAACwf,WAAW,CAAC;EACvD,MAAMV,MAAM,GAAGlS,MAAM,CAAC8S,SAAS,CAACa,IAAI,CAACzhB,MAAM,EAAEuhB,YAAY,EAAEC,YAAY,CAAC;EACxE,OAAO3B,eAAe,CAACC,KAAK,EAAEC,KAAK,EAAEC,MAAM,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAM0B,cAAc,GAAGA,CAAC5B,KAAK,EAAEC,KAAK,EAAE,CAACS,WAAW,EAAEE,WAAW,EAAEiB,UAAU,EAAEC,SAAS,EAAEC,OAAO,CAAC,KAAK;EACnG,MAAM;IACJ/T;EACF,CAAC,GAAGD,SAAS,CAAC,CAAC;EACf,MAAM0T,YAAY,GAAGrgB,qBAAqB,CAACsf,WAAW,CAAC;EACvD,MAAMgB,YAAY,GAAGtgB,qBAAqB,CAACwf,WAAW,CAAC;EACvD,MAAMV,MAAM,GAAGlS,MAAM,CAAC8S,SAAS,CAACkB,MAAM,CAACH,UAAU,EAAEC,SAAS,EAAEC,OAAO,EAAEN,YAAY,EAAEC,YAAY,CAAC;EAClG,OAAO3B,eAAe,CAACC,KAAK,EAAEC,KAAK,EAAEC,MAAM,CAAC;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM+B,iBAAiB,GAAGA,CAACC,WAAW,EAAEC,OAAO,KAAK,CAACC,OAAO,CAACF,WAAW,CAAC,IAAI,EAAE,KAAKC,OAAO,KAAKzf,SAAS,GAAG0f,OAAO,CAACD,OAAO,CAAC,GAAG,kBAAkB,CAAC;AAClJ,MAAMC,OAAO,GAAGC,MAAM,IAAI,CAACA,MAAM,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAKD,GAAG,GAAG,CAAC,IAAIC,KAAK,EAAE,CAAC,CAAC;AAErF,SAAShG,WAAW,EAAEa,YAAY,EAAEC,eAAe,EAAEG,YAAY,EAAEI,kBAAkB,EAAEZ,cAAc,EAAEU,gBAAgB,EAAEJ,mBAAmB,EAAEmB,oBAAoB,EAAEH,YAAY,EAAE9N,OAAO,EAAE5T,SAAS,EAAE6gB,iBAAiB,EAAEN,mBAAmB,EAAEQ,qBAAqB,EAAEJ,eAAe,EAAEjB,KAAK,EAAEyF,iBAAiB,EAAE1F,IAAI,EAAElO,mBAAmB,EAAEH,oBAAoB,EAAEuS,aAAa,EAAEV,eAAe,EAAEuB,iBAAiB,EAAEvT,SAAS,EAAEkT,gBAAgB,EAAEO,YAAY,EAAET,iBAAiB,EAAEa,cAAc,EAAEtF,IAAI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}