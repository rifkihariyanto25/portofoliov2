{"ast":null,"code":"import _objectWithoutProperties from \"D:/Project Visual Studio Code/Portofolio/htmlv2/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"startFrame\", \"endFrame\", \"fps\", \"frameName\", \"textureDataURL\", \"textureImageURL\", \"loop\", \"numberOfFrames\", \"autoPlay\", \"animationNames\", \"onStart\", \"onEnd\", \"onLoopEnd\", \"onFrame\", \"play\", \"pause\", \"flipX\", \"alphaTest\", \"children\", \"asSprite\", \"resetOnEnd\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef((_ref, fref) => {\n  let {\n      startFrame,\n      endFrame,\n      fps,\n      frameName,\n      textureDataURL,\n      textureImageURL,\n      loop,\n      numberOfFrames,\n      autoPlay,\n      animationNames,\n      onStart,\n      onEnd,\n      onLoopEnd,\n      onFrame,\n      play,\n      pause,\n      flipX,\n      alphaTest,\n      children,\n      asSprite,\n      resetOnEnd\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const spriteData = React.useRef(null);\n  const [isJsonReady, setJsonReady] = React.useState(false);\n  const hasEnded = React.useRef(false);\n  const matRef = React.useRef();\n  const spriteRef = React.useRef();\n  const timerOffset = React.useRef(window.performance.now());\n  const textureData = React.useRef();\n  const currentFrame = React.useRef(startFrame || 0);\n  const currentFrameName = React.useRef(frameName || '');\n  const fpsInterval = 1000 / (fps || 30);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState([1, 1, 1]);\n  const flipOffset = flipX ? -1 : 1;\n  const [displayAsSprite, setDisplayAsSprite] = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  const pauseRef = React.useRef(pause);\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const textureLoader = new THREE.TextureLoader();\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const calculateAspectRatio = (width, height) => {\n    const aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (textureDataURL && textureImageURL) {\n      loadJsonAndTextureAndExecuteCallback(textureDataURL, textureImageURL, parseSpriteData);\n    } else if (textureImageURL) {\n      // only load the texture, this is an image sprite only\n      const textureLoader = new THREE.TextureLoader();\n      new Promise(resolve => {\n        textureLoader.load(textureImageURL, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }, []);\n  React.useEffect(() => {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      hasEnded.current = false;\n      modifySpritePosition();\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstItem(spriteData.current.frames).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName]);\n  const parseSpriteData = (json, _spriteTexture) => {\n    // sprite only case\n    if (json === null) {\n      if (numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        textureData.current = _spriteTexture;\n        totalFrames.current = numberOfFrames;\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteData.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n      }\n    } else {\n      spriteData.current = json;\n      spriteData.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      textureData.current = _spriteTexture;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = _spriteTexture;\n      }\n    }\n    _spriteTexture.premultiplyAlpha = false;\n    setSpriteTexture(_spriteTexture);\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteData.current;\n    const delimiters = animationNames;\n    if (delimiters) {\n      for (let i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else if (frameName) {\n      const spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      return spritesArr;\n    }\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = () => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    setJsonReady(true);\n    if (onStart) onStart({\n      currentFrameName: frameName,\n      currentFrame: currentFrame.current\n    });\n  };\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    //if (!frameName) return\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstItem(frames).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    if (currentFrame.current > _endFrame) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        hasEnded.current = resetOnEnd ? false : true;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n      if (!loop) return;\n    }\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n    currentFrame.current += 1;\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = (metaInfo.w - 1) / frameW;\n    const framesV = (metaInfo.h - 1) / frameH;\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[currentFrame.current];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!hasEnded.current && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  const getFirstItem = param => {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      const keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: fref\n  }, props), /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }))), children);\n});\nexport { SpriteAnimator };","map":{"version":3,"names":["_extends","React","useFrame","THREE","SpriteAnimator","forwardRef","_ref","fref","startFrame","endFrame","fps","frameName","textureDataURL","textureImageURL","loop","numberOfFrames","autoPlay","animationNames","onStart","onEnd","onLoopEnd","onFrame","play","pause","flipX","alphaTest","children","asSprite","resetOnEnd","props","_objectWithoutProperties","_excluded","spriteData","useRef","isJsonReady","setJsonReady","useState","hasEnded","matRef","spriteRef","timerOffset","window","performance","now","textureData","currentFrame","currentFrameName","fpsInterval","spriteTexture","setSpriteTexture","Texture","totalFrames","aspect","setAspect","flipOffset","displayAsSprite","setDisplayAsSprite","pauseRef","loadJsonAndTextureAndExecuteCallback","jsonUrl","textureUrl","callback","textureLoader","TextureLoader","jsonPromise","fetch","then","response","json","texturePromise","Promise","resolve","load","all","calculateAspectRatio","width","height","aspectRatio","current","scale","set","useEffect","parseSpriteData","texture","useLayoutEffect","modifySpritePosition","w","h","getFirstItem","frames","sourceSize","_aspect","_spriteTexture","image","frameWidth","frameHeight","meta","version","size","parseInt","toString","i","push","frame","x","y","rotated","trimmed","spriteSourceSize","Array","isArray","parseFrames","length","Object","keys","map","premultiplyAlpha","sprites","data","delimiters","innerKey","value","frameData","sourceWidth","sourceHeight","toLowerCase","indexOf","spritesArr","key","metaInfo","frameW","frameH","wrapS","wrapT","RepeatWrapping","center","repeat","framesV","frameOffsetY","offset","runAnimation","diff","spriteFrames","_endFrame","calculateFinalPosition","finalValX","finalValY","framesH","frameX","frameY","originalSizeX","originalSizeY","frameOffsetX","Math","abs","_state","_delta","_spriteData$current","_matRef$current","param","createElement","ref","Suspense","fallback","toneMapped","transparent","args","side","DoubleSide"],"sources":["D:/Project Visual Studio Code/Portofolio/htmlv2/node_modules/@react-three/drei/core/SpriteAnimator.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\n\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef(({\n  startFrame,\n  endFrame,\n  fps,\n  frameName,\n  textureDataURL,\n  textureImageURL,\n  loop,\n  numberOfFrames,\n  autoPlay,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause,\n  flipX,\n  alphaTest,\n  children,\n  asSprite,\n  resetOnEnd,\n  ...props\n}, fref) => {\n  const spriteData = React.useRef(null);\n  const [isJsonReady, setJsonReady] = React.useState(false);\n  const hasEnded = React.useRef(false);\n  const matRef = React.useRef();\n  const spriteRef = React.useRef();\n  const timerOffset = React.useRef(window.performance.now());\n  const textureData = React.useRef();\n  const currentFrame = React.useRef(startFrame || 0);\n  const currentFrameName = React.useRef(frameName || '');\n  const fpsInterval = 1000 / (fps || 30);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState([1, 1, 1]);\n  const flipOffset = flipX ? -1 : 1;\n  const [displayAsSprite, setDisplayAsSprite] = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  const pauseRef = React.useRef(pause);\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const textureLoader = new THREE.TextureLoader();\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const calculateAspectRatio = (width, height) => {\n    const aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (textureDataURL && textureImageURL) {\n      loadJsonAndTextureAndExecuteCallback(textureDataURL, textureImageURL, parseSpriteData);\n    } else if (textureImageURL) {\n      // only load the texture, this is an image sprite only\n      const textureLoader = new THREE.TextureLoader();\n      new Promise(resolve => {\n        textureLoader.load(textureImageURL, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }, []);\n  React.useEffect(() => {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      hasEnded.current = false;\n      modifySpritePosition();\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstItem(spriteData.current.frames).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName]);\n  const parseSpriteData = (json, _spriteTexture) => {\n    // sprite only case\n    if (json === null) {\n      if (numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        textureData.current = _spriteTexture;\n        totalFrames.current = numberOfFrames;\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteData.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n      }\n    } else {\n      spriteData.current = json;\n      spriteData.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      textureData.current = _spriteTexture;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = _spriteTexture;\n      }\n    }\n    _spriteTexture.premultiplyAlpha = false;\n    setSpriteTexture(_spriteTexture);\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteData.current;\n    const delimiters = animationNames;\n    if (delimiters) {\n      for (let i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else if (frameName) {\n      const spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      return spritesArr;\n    }\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = () => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    setJsonReady(true);\n    if (onStart) onStart({\n      currentFrameName: frameName,\n      currentFrame: currentFrame.current\n    });\n  };\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    //if (!frameName) return\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstItem(frames).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    if (currentFrame.current > _endFrame) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        hasEnded.current = resetOnEnd ? false : true;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n\n      if (!loop) return;\n    }\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n    currentFrame.current += 1;\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = (metaInfo.w - 1) / frameW;\n    const framesV = (metaInfo.h - 1) / frameH;\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[currentFrame.current];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!hasEnded.current && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  const getFirstItem = param => {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      const keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: fref\n  }, props), /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(\"mesh\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }))), children);\n});\n\nexport { SpriteAnimator };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}